<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>大数据团队scala代码规范 | Adam Home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">大数据团队scala代码规范</h1><a id="logo" href="/.">Adam Home</a><p class="description">快意回首，拂心莫停</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于我</i></a><a href="/timeline/"><i class="fa fa-line-chart"> 历史</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">大数据团队scala代码规范</h1><div class="post-meta">Jan 9, 2017<span> | </span><span class="category"><a href="/categories/scala/">scala</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="一、-scala代码规范"><a href="#一、-scala代码规范" class="headerlink" title="一、 scala代码规范"></a>一、 scala代码规范</h3><p>Scala 是一种强大到令人难以置信的多范式编程语言。目前我们团队有很多项目需要使用scala语言进行编程，尤其是Spark相关开发项目，为了能够统一scala相关开发，本人基于Spark 贡献者及 <a href="http://databricks.com/" target="_blank" rel="external">Databricks</a> 工程团队总结出了以下指南，本人增加了单元测试的规范，希望对大家的开发有帮助。当然，这个指南并非绝对，根据我们团队需求与实际经验，持续更新。</p>
<h3 id="二、-选择此规范的理由"><a href="#二、-选择此规范的理由" class="headerlink" title="二、 选择此规范的理由"></a>二、 选择此规范的理由</h3><p>很早就有大家统一编程规范的想法，网上也有一些关于编程规范的文档供参考。最终选择了以 Databricks 公司的编程规范为模板制作。理由如下：</p>
<ul>
<li>目前公司使用scala语言主要用在Spark的开发，而这份指南是Spark 贡献者及 Databricks 工程团队一起工作时总结出来的；</li>
<li>跟我们之前写得代码，以及IDEA等编译器自动格式化相差不大；</li>
<li>这份指南经过多次的修改和总结，经过了实践的检验；</li>
<li>这份指南相比较而言简明概要，易于理解，遵循 Java 的地方就没有赘述，比较解耦，适用于根据公司代码体系来修改；</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name="TOC">目录</a></h2><ol>
<li><a href="#history">文档历史</a></li>
<li><a href="#syntactic">语法风格</a><ul>
<li><a href="#naming">命名约定</a></li>
<li><a href="#variable-naming">变量命名约定</a></li>
<li><a href="#linelength">一行长度</a></li>
<li><a href="#rule_of_30">30 法则</a></li>
<li><a href="#indent">空格与缩进</a></li>
<li><a href="#blanklines">空行</a></li>
<li><a href="#parentheses">括号</a></li>
<li><a href="#curly">大括号</a></li>
<li><a href="#long_literal">长整型字面量</a></li>
<li><a href="#doc">文档风格</a></li>
<li><a href="#ordering_class">类内秩序</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#pattern-matching">模式匹配</a></li>
<li><a href="#infix">中缀方法</a></li>
<li><a href="#anonymous">匿名方法</a></li>
</ul>
</li>
<li><a href="#lang">Scala 语言特性</a><ul>
<li><a href="#case_class_immutability">样例类与不可变性</a></li>
<li><a href="#apply_method">apply 方法</a></li>
<li><a href="#override_modifier">override 修饰符</a></li>
<li><a href="#destruct_bind">解构绑定</a></li>
<li><a href="#call_by_name">按名称传参</a></li>
<li><a href="#multi-param-list">多参数列表</a></li>
<li><a href="#symbolic_methods">符号方法 (运算符重载)</a></li>
<li><a href="#type_inference">类型推导</a></li>
<li><a href="#return">Return 语句</a></li>
<li><a href="#recursion">递归及尾递归</a></li>
<li><a href="#implicits">Implicits</a></li>
<li><a href="#exception">异常处理 (Try 还是 try)</a></li>
<li><a href="#option">Options</a></li>
<li><a href="#chaining">单子链接</a></li>
</ul>
</li>
<li><a href="#concurrency">并发</a><ul>
<li><a href="#concurrency-scala-collection">Scala concurrent.Map</a></li>
<li><a href="#concurrency-sync-vs-map">显式同步 vs 并发集合</a></li>
<li><a href="#concurrency-sync-vs-atomic">显式同步 vs 原子变量 vs @volatile</a></li>
<li><a href="#concurrency-private-this">私有字段</a></li>
<li><a href="#concurrency-isolation">隔离</a></li>
</ul>
</li>
<li><a href="#perf">性能</a><ul>
<li><a href="#perf-microbenchmarks">Microbenchmarks</a></li>
<li><a href="#perf-whileloops">Traversal 与 zipWithIndex</a></li>
<li><a href="#perf-option">Option 与 null</a></li>
<li><a href="#perf-collection">Scala 集合库</a></li>
<li><a href="#perf-private">private[this]</a></li>
</ul>
</li>
<li><a href="#java">与 Java 的互操作性</a><ul>
<li><a href="#java-missing-features">Scala 中缺失的 Java 特性</a></li>
<li><a href="#java-traits">Traits 与抽象类</a></li>
<li><a href="#java-type-alias">类型别名</a></li>
<li><a href="#java-default-param-values">默认参数值</a></li>
<li><a href="#java-multi-param-list">多参数列表</a></li>
<li><a href="#java-varargs">可变参数</a></li>
<li><a href="#java-implicits">Implicits</a></li>
<li><a href="#java-companion-object">伴生对象, 静态方法与字段</a></li>
</ul>
</li>
<li><a href="#misc">其它</a><ul>
<li><a href="#misc_currentTimeMillis_vs_nanoTime">优先使用 nanoTime 而非 currentTimeMillis</a></li>
<li><a href="#misc_uri_url">优先使用 URI 而非 URL</a></li>
</ul>
</li>
<li><a href="#unit-test">单元测试</a><ul>
<li><a href="#unit-test-framework">单元测试框架</a></li>
<li><a href="#unit-test-style">单元测试风格</a></li>
</ul>
</li>
</ol>
<h2 id="文档历史"><a href="#文档历史" class="headerlink" title="文档历史"></a><a name="history">文档历史</a></h2><ul>
<li>2017-01-10: 最初版本。<a href="https://github.com/databricks/scala-style-guide/blob/master/README-ZH.md" target="_blank" rel="external">Databricks版本</a></li>
<li>2017-01-11: 增加 <a href="#unit-test">单元测试</a> 一节。</li>
</ul>
<h2 id="语法风格"><a href="#语法风格" class="headerlink" title="语法风格"></a><a name="syntactic">语法风格</a></h2><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a><a name="naming">命名约定</a></h3><p>我们主要遵循 Java 和 Scala 的标准命名约定。</p>
<ul>
<li><p>类，trait, 对象应该遵循 Java 中类的命名约定，即 PascalCase 风格。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClusterManager</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expression</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>包名应该遵循 Java 中包名的命名约定，即使用全小写的 ASCII 字母。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.databricks.resourcemanager</div></pre></td></tr></table></figure>
</li>
<li><p>方法/函数应当使用驼峰式风格命名。</p>
</li>
<li><p>常量命名使用全大写字母，并将它们放在伴生对象中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Configuration</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> <span class="type">DEFAULT_PORT</span> = <span class="number">10000</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>枚举命名与类命名一致，使用 PascalCase 风格。</p>
</li>
<li><p>注解也应遵循 Java 中的约定，即使用 PascalCase 风格。注意，这一点与 Scala 的官方指南不同。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotation</span> <span class="keyword">extends</span> <span class="title">StaticAnnotation</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="变量命名约定"><a href="#变量命名约定" class="headerlink" title="变量命名约定"></a><a name="variable-naming">变量命名约定</a></h3><ul>
<li><p>变量命名应当遵循驼峰式命名方法，并且变量名应当是不言而喻的，即变量名可以直观地反应它的涵义。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> serverPort = <span class="number">1000</span></div><div class="line"><span class="keyword">val</span> clientPort = <span class="number">2000</span></div></pre></td></tr></table></figure>
</li>
<li><p>可以在小段的局部代码中使用单字符的变量名，比如在小段的循环体中（例如 10 行以内的代码），“i” 常常被用作循环索引。然而，即使在小段的代码中，也不要使用 “l” （Larry 中的 l）作为标识符，因为它看起来和 “1”，“|”，“I” 很像，难以区分，容易搞错。</p>
</li>
</ul>
<h3 id="一行长度"><a href="#一行长度" class="headerlink" title="一行长度"></a><a name="linelength">一行长度</a></h3><ul>
<li>一行长度的上限是 100 个字符。</li>
<li>唯一的例外是 import 语句和 URL (即便如此，也尽量将它们保持在 100 个字符以下)。</li>
</ul>
<h3 id="30-法则"><a href="#30-法则" class="headerlink" title="30 法则"></a><a name="rule_of_30">30 法则</a></h3><p>「如果一个元素包含的子元素超过 30 个，那么极有可能出现了严重的问题」 - <a href="http://www.amazon.com/Refactoring-Large-Software-Projects-Restructurings/dp/0470858923" target="_blank" rel="external">Refactoring in Large Software Projects</a>。</p>
<p>一般来说:</p>
<ul>
<li>一个方法包含的代码行数不宜超过 30 行。</li>
<li>一个类包含的方法数量不宜超过 30 个。</li>
</ul>
<h3 id="空格与缩进"><a href="#空格与缩进" class="headerlink" title="空格与缩进"></a><a name="indent">空格与缩进</a></h3><ul>
<li><p>一般情况下，使用两个空格的缩进。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  println(<span class="string">"Wow!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对于方法声明，如果一行无法容纳下所有的参数，那么使用 4 个空格来缩进它们。返回类型可以与最后一个参数在同一行，也可以放在下一行，使用两个空格缩进。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">newAPIHadoopFile</span></span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">F</span> &lt;: <span class="type">NewInputFormat</span>[<span class="type">K</span>, <span class="type">V</span>]](</div><div class="line">    path: <span class="type">String</span>,</div><div class="line">    fClass: <span class="type">Class</span>[<span class="type">F</span>],</div><div class="line">    kClass: <span class="type">Class</span>[<span class="type">K</span>],</div><div class="line">    vClass: <span class="type">Class</span>[<span class="type">V</span>],</div><div class="line">    conf: <span class="type">Configuration</span> = hadoopConfiguration): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = &#123;</div><div class="line">  <span class="comment">// method body</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">newAPIHadoopFile</span></span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">F</span> &lt;: <span class="type">NewInputFormat</span>[<span class="type">K</span>, <span class="type">V</span>]](</div><div class="line">    path: <span class="type">String</span>,</div><div class="line">    fClass: <span class="type">Class</span>[<span class="type">F</span>],</div><div class="line">    kClass: <span class="type">Class</span>[<span class="type">K</span>],</div><div class="line">    vClass: <span class="type">Class</span>[<span class="type">V</span>],</div><div class="line">    conf: <span class="type">Configuration</span> = hadoopConfiguration)</div><div class="line">  : <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = &#123;</div><div class="line">  <span class="comment">// method body</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果一行无法容纳下类头（即 extends 后面那部分），则把它们放到新的一行，用两个空格缩进，然后在类内空一行再开始函数或字段的定义（或是包的导入）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"></span></span></div><div class="line">    val param1: <span class="type">String</span>,  // 4 space indent for parameters</div><div class="line">    val param2: <span class="type">String</span>,</div><div class="line">    val param3: <span class="type">Array</span>[<span class="type">Byte</span>])</div><div class="line">  <span class="keyword">extends</span> <span class="type">FooInterface</span>  <span class="comment">// 2 space here</span></div><div class="line">  <span class="keyword">with</span> <span class="type">Logging</span> &#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">firstMethod</span></span>(): <span class="type">Unit</span> = &#123; ... &#125;  <span class="comment">// blank line above</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>不要使用垂直对齐。它使你的注意力放在代码的错误部分并增大了后人修改代码的难度。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Don't align vertically</span></div><div class="line"><span class="keyword">val</span> plus     = <span class="string">"+"</span></div><div class="line"><span class="keyword">val</span> minus    = <span class="string">"-"</span></div><div class="line"><span class="keyword">val</span> multiply = <span class="string">"*"</span></div><div class="line"></div><div class="line"><span class="comment">// Do the following</span></div><div class="line"><span class="keyword">val</span> plus = <span class="string">"+"</span></div><div class="line"><span class="keyword">val</span> minus = <span class="string">"-"</span></div><div class="line"><span class="keyword">val</span> multiply = <span class="string">"*"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a><a name="blanklines">空行</a></h3><ul>
<li>一个空行可以出现在：<ul>
<li>连续的类成员或初始化器（initializers）之间：字段，构造函数，方法，嵌套类，静态初始化器及实例初始化器。<ul>
<li>例外：连续的两个字段之间的空行是可选的（前提是它们之间没有其它代码），这一类空行主要为这些字段做逻辑上的分组。</li>
</ul>
</li>
<li>在方法体内，根据需要，使用空行来为语句创建逻辑上的分组。</li>
<li>在类的第一个成员之前或最后一个成员之后，空行都是可选的（既不鼓励也不阻止）。</li>
</ul>
</li>
<li>使用一个或两个空行来分隔不同类的定义。</li>
<li>不鼓励使用过多的空行。</li>
</ul>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a><a name="parentheses">括号</a></h3><ul>
<li><p>方法声明应该加括号（即使没有参数列表），除非它们是没有副作用（状态改变，IO 操作都认为是有副作用的）的访问器（accessor）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</div><div class="line">  <span class="comment">// Wrong: killJob changes state. Should have ().</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">killJob</span></span>: <span class="type">Unit</span></div><div class="line"></div><div class="line">  <span class="comment">// Correct:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">killJob</span></span>(): <span class="type">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>函数调用应该与函数声明在形式上保持一致，也就是说，如果一个方法声明时带了括号，那调用时也要把括号带上。注意这不仅仅是语法层面的人为约定，当返回对象中定义了 <code>apply</code> 方法时，这一点还会影响正确性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(args: <span class="type">String</span>*): <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>: <span class="type">Foo</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="type">Bar</span>().foo  <span class="comment">// This returns a Foo</span></div><div class="line"><span class="keyword">new</span> <span class="type">Bar</span>().foo()  <span class="comment">// This returns an Int!</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a><a name="curly">大括号</a></h3><p>即使条件语句或循环语句只有一行时，也请使用大括号。唯一的例外是，当你把 if/else 作为一个单行的三元操作符来使用并且没有副作用时，这时你可以不加大括号。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Correct:</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  println(<span class="string">"Wow!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Correct:</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) statement1 <span class="keyword">else</span> statement2</div><div class="line"></div><div class="line"><span class="comment">// Correct:</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  foo()</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Wrong:</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</div><div class="line">  println(<span class="string">"Wow!"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Wrong:</span></div><div class="line"><span class="keyword">try</span> foo() <span class="keyword">catch</span> &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="长整型字面量"><a href="#长整型字面量" class="headerlink" title="长整型字面量"></a><a name="long_literal">长整型字面量</a></h3><p>长整型字面量使用大写的 <code>L</code> 作为后缀，不要使用小写，因为它和数字 <code>1</code> 长得很像，常常难以区分。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> longValue = <span class="number">5432</span>L  <span class="comment">// Do this</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> longValue = <span class="number">5432</span>l  <span class="comment">// Do NOT do this</span></div></pre></td></tr></table></figure>
<h3 id="文档风格"><a href="#文档风格" class="headerlink" title="文档风格"></a><a name="doc">文档风格</a></h3><p>使用 Java Doc 风格，而非 Scala Doc 风格。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** This is a correct one-liner, short description. */</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * This is correct multi-line JavaDoc comment. And</div><div class="line"> * this is my second line, and if I keep typing, this would be</div><div class="line"> * my third line.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/** In Spark, we don't use the ScalaDoc style so this</span></div><div class="line">  * is not correct.</div><div class="line">  */</div></pre></td></tr></table></figure>
<h3 id="类内秩序"><a href="#类内秩序" class="headerlink" title="类内秩序"></a><a name="ordering_class">类内秩序</a></h3><p>如果一个类很长，包含许多的方法，那么在逻辑上把它们分成不同的部分并加上注释头，以此组织它们。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataFrame</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">///////////////////////////////////////////////////////////////////////////</span></div><div class="line">  <span class="comment">// DataFrame operations</span></div><div class="line">  <span class="comment">///////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">///////////////////////////////////////////////////////////////////////////</span></div><div class="line">  <span class="comment">// RDD operations</span></div><div class="line">  <span class="comment">///////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，强烈不建议把一个类写得这么长，一般只有在构建某些公共 API 时才允许这么做。</p>
<h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a><a name="imports">Imports</a></h3><ul>
<li><strong>导入时避免使用通配符</strong>, 除非你需要导入超过 6 个实体或者隐式方法。通配符导入会使代码在面对外部变化时不够健壮。</li>
<li>始终使用绝对路径来导入包 (如：<code>scala.util.Random</code>) ，而不是相对路径 (如：<code>util.Random</code>)。</li>
<li>此外，导入语句按照以下顺序排序：<ul>
<li><code>java.*</code> 和 <code>javax.*</code></li>
<li><code>scala.*</code></li>
<li>第三方库 (<code>org.*</code>, <code>com.*</code>, 等)</li>
<li>项目中的类 (对于 Spark 项目，即 <code>com.databricks.*</code> 或 <code>org.apache.spark</code>)</li>
</ul>
</li>
<li>在每一组导入语句内，按照字母序进行排序。</li>
<li><p>你可以使用 IntelliJ 的「import organizer」来自动处理，请使用以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">java</div><div class="line">javax</div><div class="line">_______ blank line _______</div><div class="line">scala</div><div class="line">_______ blank line _______</div><div class="line">all other imports</div><div class="line">_______ blank line _______</div><div class="line">com.databricks  // or org.apache.spark if you are working on spark</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a><a name="pattern-matching">模式匹配</a></h3><ul>
<li><p>如果整个方法就是一个模式匹配表达式，可能的话，可以把 match 关键词与方法声明放在同一行，以此减少一级缩进。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(msg: <span class="type">Message</span>): <span class="type">Unit</span> = msg <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当以闭包形式调用一个函数时，如果只有一个 case 语句，那么把 case 语句与函数调用放在同一行。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.zipWithIndex.map &#123; <span class="keyword">case</span> (elem, i) =&gt;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有多个 case 语句，把它们缩进并且包起来。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list.map &#123;</div><div class="line">  <span class="keyword">case</span> a: <span class="type">Foo</span> =&gt;  ...</div><div class="line">  <span class="keyword">case</span> b: <span class="type">Bar</span> =&gt;  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果唯一的目的就是想匹配某个对象的类型，那么不要展开所有的参数来做模式匹配，这样会使得重构变得更加困难，代码更容易出错。</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Pokemon</span>(<span class="params">name: <span class="type">String</span>, weight: <span class="type">Int</span>, hp: <span class="type">Int</span>, attack: <span class="type">Int</span>, defense: <span class="type">Int</span></span>)</span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span>(<span class="params">name: <span class="type">String</span>, hp: <span class="type">Int</span></span>)</span></div><div class="line"></div><div class="line"><span class="comment">// 不要像下面那样做，因为</span></div><div class="line"><span class="comment">// 1. 当 pokemon 加入一个新的字段，我们需要改变下面的模式匹配代码</span></div><div class="line"><span class="comment">// 2. 非常容易发生误匹配，尤其是当所有字段的类型都一样的时候</span></div><div class="line">targets.foreach &#123;</div><div class="line">  <span class="keyword">case</span> target @ <span class="type">Pokemon</span>(_, _, hp, _, defense) =&gt;</div><div class="line">    <span class="keyword">val</span> loss = sys.min(<span class="number">0</span>, myAttack - defense)</div><div class="line">    target.copy(hp = hp - loss)</div><div class="line">  <span class="keyword">case</span> target @ <span class="type">Human</span>(_, hp) =&gt;</div><div class="line">    target.copy(hp = hp - myAttack)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 像下面这样做就好多了:</span></div><div class="line">targets.foreach &#123;</div><div class="line">  <span class="keyword">case</span> target: <span class="type">Pokemon</span> =&gt;</div><div class="line">    <span class="keyword">val</span> loss = sys.min(<span class="number">0</span>, myAttack - target.defense)</div><div class="line">    target.copy(hp = target.hp - loss)</div><div class="line">  <span class="keyword">case</span> target: <span class="type">Human</span> =&gt;</div><div class="line">    target.copy(hp = target.hp - myAttack)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中缀方法"><a href="#中缀方法" class="headerlink" title="中缀方法"></a><a name="infix">中缀方法</a></h3><p><strong>避免中缀表示法</strong>，除非是符号方法（即运算符重载）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Correct</span></div><div class="line">list.map(func)</div><div class="line">string.contains(<span class="string">"foo"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Wrong</span></div><div class="line">list map (func)</div><div class="line">string contains <span class="string">"foo"</span></div><div class="line"></div><div class="line"><span class="comment">// 重载的运算符应该以中缀形式调用</span></div><div class="line">arrayBuffer += elem</div></pre></td></tr></table></figure>
<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a><a name="anonymous">匿名方法</a></h3><p>对于匿名方法，<strong>避免使用过多的小括号和花括号</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Correct</span></div><div class="line">list.map &#123; item =&gt;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Correct</span></div><div class="line">list.map(item =&gt; ...)</div><div class="line"></div><div class="line"><span class="comment">// Wrong</span></div><div class="line">list.map(item =&gt; &#123;</div><div class="line">  ...</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Wrong</span></div><div class="line">list.map &#123; item =&gt; &#123;</div><div class="line">  ...</div><div class="line">&#125;&#125;</div><div class="line"></div><div class="line"><span class="comment">// Wrong</span></div><div class="line">list.map(&#123; item =&gt; ... &#125;)</div></pre></td></tr></table></figure>
<h2 id="Scala-语言特性"><a href="#Scala-语言特性" class="headerlink" title="Scala 语言特性"></a><a name="lang">Scala 语言特性</a></h2><h3 id="样例类与不可变性"><a href="#样例类与不可变性" class="headerlink" title="样例类与不可变性"></a><a name="case_class_immutability">样例类与不可变性</a></h3><p>样例类（case class）本质也是普通的类，编译器会自动地为它加上以下支持：</p>
<ul>
<li>构造器参数的公有 getter 方法</li>
<li>拷贝构造函数</li>
<li>构造器参数的模式匹配</li>
<li>默认的 toString/hash/equals 实现</li>
</ul>
<p>对于样例类来说，构造器参数不应设为可变的，可以使用拷贝构造函数达到同样的效果。使用可变的样例类容易出错，例如，哈希表中，对象根据旧的哈希值被放在错误的位置上。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This is OK</span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></div><div class="line"></div><div class="line"><span class="comment">// This is NOT OK</span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, var age: <span class="type">Int</span></span>)</span></div><div class="line"></div><div class="line"><span class="comment">// 通过拷贝构造函数创建一个新的实例来改变其中的值</span></div><div class="line"><span class="keyword">val</span> p1 = <span class="type">Person</span>(<span class="string">"Peter"</span>, <span class="number">15</span>)</div><div class="line"><span class="keyword">val</span> p2 = p2.copy(age = <span class="number">16</span>)</div></pre></td></tr></table></figure>
<h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a><a name="apply_method">apply 方法</a></h3><p>避免在类里定义 apply 方法。这些方法往往会使代码的可读性变差，尤其是对于不熟悉 Scala 的人。它也难以被 IDE（或 grep）所跟踪。在最坏的情况下，它还可能影响代码的正确性，正如你在<a href="#parentheses">括号</a>一节中看到的。</p>
<p>然而，将 apply 方法作为工厂方法定义在伴生对象中是可以接受的。在这种情况下，apply 方法应该返回其伴生类的类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">  <span class="comment">// 下面这种定义是 OK 的</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">TreeNode</span> = ...</div><div class="line"></div><div class="line">  <span class="comment">// 不要像下面那样定义，因为它没有返回其伴生类的类型：TreeNode</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">String</span> = ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="override-修饰符"><a href="#override-修饰符" class="headerlink" title="override 修饰符"></a><a name="override_modifier">override 修饰符</a></h3><p>无论是覆盖具体的方法还是实现抽象的方法，始终都为方法加上 override 修饰符。实现抽象方法时，不加 override 修饰符，Scala 编译器也不会报错。即便如此，我们也应该始终把 override 修饰符加上，以此显式地表示覆盖行为。以此避免由于方法签名不同（而你也难以发现）而导致没有覆盖到本应覆盖的方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(data: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    print(data)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">  <span class="keyword">import</span> scala.collection.<span class="type">Map</span></div><div class="line"></div><div class="line">  <span class="comment">// 下面的方法没有覆盖 Parent.hello,</span></div><div class="line">  <span class="comment">// 因为两个 Map 的类型是不同的。</span></div><div class="line">  <span class="comment">// 如果我们加上 override 修饰符，编译器就会帮你找出问题并报错。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(data: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    print(<span class="string">"This is supposed to override the parent method, but it is actually not!"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解构绑定"><a href="#解构绑定" class="headerlink" title="解构绑定"></a><a name="destruct_bind">解构绑定</a></h3><p>解构绑定（有时也叫元组提取）是一种在一个表达式中为两个变量赋值的便捷方式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> (a, b) = (<span class="number">1</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>然而，请不要在构造函数中使用它们，尤其是当 <code>a</code> 和 <code>b</code> 需要被标记为 <code>transient</code> 的时候。Scala 编译器会产生一个额外的 Tuple2 字段，而它并不是暂态的（transient）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">  <span class="comment">// 以下代码无法 work，因为编译器会产生一个非暂态的 Tuple2 指向 a 和 b</span></div><div class="line">  <span class="meta">@transient</span> <span class="keyword">private</span> <span class="keyword">val</span> (a, b) = someFuncThatReturnsTuple2()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="按名称传参"><a href="#按名称传参" class="headerlink" title="按名称传参"></a><a name="call_by_name">按名称传参</a></h3><p><strong>避免使用按名传参</strong>. 显式地使用 <code>() =&gt; T</code> 。</p>
<p>背景：Scala 允许按名称来定义方法参数，例如：以下例子是可以成功执行的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span></span>(value: =&gt; <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  println(value)</div><div class="line">  println(value + <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">0</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(): <span class="type">Int</span> = &#123;</div><div class="line">  a += <span class="number">1</span></div><div class="line">  a</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(inc())</div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>inc()</code> 以闭包的形式传递给 <code>print</code> 函数，并且在 <code>print</code> 函数中被执行了两次，而不是以数值 <code>1</code> 传入。按名传参的一个主要问题是在方法调用处，我们无法区分是按名传参还是按值传参。因此无法确切地知道这个表达式是否会被执行（更糟糕的是它可能会被执行多次）。对于带有副作用的表达式来说，这一点是非常危险的。</p>
<h3 id="多参数列表"><a href="#多参数列表" class="headerlink" title="多参数列表"></a><a name="multi-param-list">多参数列表</a></h3><p><strong>避免使用多参数列表</strong>。它们使运算符重载变得复杂，并且会使不熟悉 Scala 的程序员感到困惑。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Avoid this!</span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)(<span class="params">secret: <span class="type">String</span></span>)</span></div></pre></td></tr></table></figure>
<p>一个值得注意的例外是，当在定义底层库时，可以使用第二个参数列表来存放隐式（implicit）参数。尽管如此，<a href="#implicits">我们应该避免使用 implicits</a>！</p>
<h3 id="符号方法（运算符重载）"><a href="#符号方法（运算符重载）" class="headerlink" title="符号方法（运算符重载）"></a><a name="symbolic_methods">符号方法（运算符重载）</a></h3><p><strong>不要使用符号作为方法名</strong>，除非你是在定义算术运算的方法（如：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>），否则在任何其它情况下，都不要使用。符号化的方法名让人难以理解方法的意图是什么，来看下面两个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 符号化的方法名难以理解</span></div><div class="line">channel ! msg</div><div class="line">stream1 &gt;&gt;= stream2</div><div class="line"></div><div class="line"><span class="comment">// 下面的方法意图则不言而喻</span></div><div class="line">channel.send(msg)</div><div class="line">stream1.join(stream2)</div></pre></td></tr></table></figure>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a><a name="type_inference">类型推导</a></h3><p>Scala 的类型推导，尤其是左侧类型推导以及闭包推导，可以使代码变得更加简洁。尽管如此，也有一些情况我们是需要显式地声明类型的：</p>
<ul>
<li><strong>公有方法应该显式地声明类型</strong>，编译器推导出来的类型往往会使你大吃一惊。</li>
<li><strong>隐式方法应该显式地声明类型</strong>，否则在增量编译时，它会使 Scala 编译器崩溃。</li>
<li><strong>如果变量或闭包的类型并非显而易见，请显式声明类型</strong>。一个不错的判断准则是，如果评审代码的人无法在 3 秒内确定相应实体的类型，那么你就应该显式地声明类型。</li>
</ul>
<h3 id="Return-语句"><a href="#Return-语句" class="headerlink" title="Return 语句"></a><a name="return">Return 语句</a></h3><p><strong>闭包中避免使用 return</strong>。<code>return</code> 会被编译器转成 <code>scala.runtime.NonLocalReturnControl</code> 异常的 <code>try/catch</code> 语句，这可能会导致意外行为。请看下面的例子：</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>(rpc: <span class="type">WebSocketRPC</span>): <span class="type">Option</span>[<span class="type">Response</span>] = &#123;</div><div class="line">  tableFut.onComplete &#123; table =&gt;</div><div class="line">    <span class="keyword">if</span> (table.isFailure) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="type">None</span> <span class="comment">// Do not do that!</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; ... &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>.onComplete</code> 方法接收一个匿名闭包并把它传递到一个不同的线程中。这个闭包最终会抛出一个 <code>NonLocalReturnControl</code> 异常，并在 <strong>一个不同的线程中</strong>被捕获，而这里执行的方法却没有任何影响。</p>
<p>然而，也有少数情况我们是推荐使用 <code>return</code> 的。</p>
<ul>
<li><p>使用 <code>return</code> 来简化控制流，避免增加一级缩进。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomething</span></span>(obj: <span class="type">Any</span>): <span class="type">Any</span> = &#123;</div><div class="line">  <span class="keyword">if</span> (obj eq <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// do something ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>return</code> 来提前终止循环，这样就不用额外构造状态标志。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (cond) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="递归及尾递归"><a href="#递归及尾递归" class="headerlink" title="递归及尾递归"></a><a name="recursion">递归及尾递归</a></h3><p><strong>避免使用递归</strong>，除非问题可以非常自然地用递归来描述（比如，图和树的遍历）。</p>
<p>对于那些你意欲使之成为尾递归的方法，请加上 <code>@tailrec</code> 注解以确保编译器去检查它是否真的是尾递归（你会非常惊讶地看到，由于使用了闭包和函数变换，许多看似尾递归的代码事实并非尾递归）。</p>
<p>大多数的代码使用简单的循环和状态机会更容易推理，使用尾递归反而可能会使它更加繁琐且难以理解。例如，下面的例子中，命令式的代码比尾递归版本的代码要更加易读：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Tail recursive version.</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(data: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</div><div class="line">  <span class="meta">@tailrec</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">max0</span></span>(data: <span class="type">Array</span>[<span class="type">Int</span>], pos: <span class="type">Int</span>, max: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</div><div class="line">    <span class="keyword">if</span> (pos == data.length) &#123;</div><div class="line">      max</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      max0(data, pos + <span class="number">1</span>, <span class="keyword">if</span> (data(pos) &gt; max) data(pos) <span class="keyword">else</span> max)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  max0(data, <span class="number">0</span>, <span class="type">Int</span>.<span class="type">MinValue</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Explicit loop version</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(data: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</div><div class="line">  <span class="keyword">var</span> max = <span class="type">Int</span>.<span class="type">MinValue</span></div><div class="line">  <span class="keyword">for</span> (v &lt;- data) &#123;</div><div class="line">    <span class="keyword">if</span> (v &gt; max) &#123;</div><div class="line">      max = v</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  max</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Implicits"><a href="#Implicits" class="headerlink" title="Implicits"></a><a name="implicits">Implicits</a></h3><p><strong>避免使用 implicit</strong>，除非：</p>
<ul>
<li>你在构建领域特定的语言（DSL）</li>
<li>你在隐式类型参数中使用它（如：<code>ClassTag</code>，<code>TypeTag</code>）</li>
<li>你在你自己的类中使用它（意指不要污染外部空间），以此减少类型转换的冗余度（如：Scala 闭包到 Java 闭包的转换）。</li>
</ul>
<p>当使用 implicit 时，我们应该确保另一个工程师可以直接理解使用语义，而无需去阅读隐式定义本身。Implicit 有着非常复杂的解析规则，这会使代码变得极其难以理解。Twitter 的 Effective Scala 指南中写道：「如果你发现你在使用 implicit，始终停下来问一下你自己，是否可以在不使用 implicit 的条件下达到相同的效果」。</p>
<p>如果你必需使用它们（比如：丰富 DSL），那么不要重载隐式方法，即确保每个隐式方法有着不同的名字，这样使用者就可以选择性地导入它们。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 别这么做，这样使用者无法选择性地只导入其中一个方法。</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitHolder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toRdd</span></span>(seq: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">RDD</span>[<span class="type">Int</span>] = ...</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toRdd</span></span>(seq: <span class="type">Seq</span>[<span class="type">Long</span>]): <span class="type">RDD</span>[<span class="type">Long</span>] = ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 应该将它们定义为不同的名字：</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitHolder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">intSeqToRdd</span></span>(seq: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">RDD</span>[<span class="type">Int</span>] = ...</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">longSeqToRdd</span></span>(seq: <span class="type">Seq</span>[<span class="type">Long</span>]): <span class="type">RDD</span>[<span class="type">Long</span>] = ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="异常处理-Try-还是-try"><a href="#异常处理-Try-还是-try" class="headerlink" title="异常处理 (Try 还是 try)"></a><a name="exception">异常处理 (Try 还是 try)</a></h2><ul>
<li><p>不要捕获 Throwable 或 Exception 类型的异常。请使用 <code>scala.util.control.NonFatal</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</div><div class="line">    <span class="comment">// 异常处理；注意 NonFatal 无法匹配 InterruptedException 类型的异常</span></div><div class="line">  <span class="keyword">case</span> e: <span class="type">InterruptedException</span> =&gt;</div><div class="line">    <span class="comment">// 处理 InterruptedException</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这能保证我们不会去捕获 <code>NonLocalReturnControl</code> 异常（正如在<a href="#return">Return 语句</a>中所解释的）。</p>
</li>
<li><p>不要在 API 中使用 <code>Try</code>，即，不要在任何方法中返回 Try。对于异常执行，请显式地抛出异常，并使用 Java 风格的 try/catch 做异常处理。</p>
<p>背景资料：Scala 提供了单子（monadic）错误处理（通过 <code>Try</code>，<code>Success</code> 和 <code>Failure</code>），这样便于做链式处理。然而，根据我们的经验，发现使用它通常会带来更多的嵌套层级，使得代码难以阅读。此外，对于预期错误还是异常，在语义上常常是不明晰的。因此，我们不鼓励使用 <code>Try</code> 来做错误处理，尤其是以下情况：</p>
<p>一个人为的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">  <span class="comment">/** Look up a user's profile in the user database. */</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(userId: <span class="type">Int</span>): <span class="type">Try</span>[<span class="type">User</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下的写法会更好：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Look up a user's profile in the user database.</div><div class="line">   * @return None if the user is not found.</div><div class="line">   * @throws DatabaseConnectionException when we have trouble connecting to the database/</div><div class="line">   */</div><div class="line">  <span class="meta">@throws</span>(<span class="type">DatabaseConnectionException</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(userId: <span class="type">Int</span>): <span class="type">Option</span>[<span class="type">User</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种写法非常明显地能让调用者知道需要处理哪些错误情况。</p>
</li>
</ul>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a><a name="option">Options</a></h3><ul>
<li>如果一个值可能为空，那么请使用 <code>Option</code>。相对于 <code>null</code>，<code>Option</code> 显式地表明了一个 API 的返回值可能为空。</li>
<li><p>构造 <code>Option</code> 值时，请使用 <code>Option</code> 而非 <code>Some</code>，以防那个值为 <code>null</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMethod1</span></span>(input: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Option</span>(transform(input))</div><div class="line"></div><div class="line"><span class="comment">// This is not as robust because transform can return null, and then</span></div><div class="line"><span class="comment">// myMethod2 will return Some(null).</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMethod2</span></span>(input: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(transform(input))</div></pre></td></tr></table></figure>
</li>
<li><p>不要使用 None 来表示异常，有异常时请显式抛出。</p>
</li>
<li>不要在一个 <code>Option</code> 值上直接调用 <code>get</code> 方法，除非你百分百确定那个 <code>Option</code> 值不是 <code>None</code>。</li>
</ul>
<h3 id="单子链接"><a href="#单子链接" class="headerlink" title="单子链接"></a><a name="chaining">单子链接</a></h3><p>单子链接是 Scala 的一个强大特性。Scala 中几乎一切都是单子（如：集合，Option，Future，Try 等），对它们的操作可以链接在一起。这是一个非常强大的概念，但你应该谨慎使用，尤其是：</p>
<ul>
<li>避免链接（或嵌套）超过 3 个操作。</li>
<li>如果需要花超过 5 秒钟来理解其中的逻辑，那么你应该尽量去想想有没什么办法在不使用单子链接的条件下来达到相同的效果。一般来说，你需要注意的是：不要滥用 <code>flatMap</code> 和 <code>fold</code>。</li>
<li>链接应该在 flatMap 之后断开（因为类型发生了变化）。</li>
</ul>
<p>通过给中间结果显式地赋予一个变量名，将链接断开变成一种更加过程化的风格，能让单子链接更加易于理解。来看下面的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val data: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]</span>)</span></div><div class="line"><span class="keyword">val</span> database = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Person</span>]</div><div class="line"><span class="comment">// Sometimes the client can store "null" value in the  store "address"</span></div><div class="line"></div><div class="line"><span class="comment">// A monadic chaining approach</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAddress</span></span>(name: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = &#123;</div><div class="line">  database.get(name).flatMap &#123; elem =&gt;</div><div class="line">    elem.data.get(<span class="string">"address"</span>)</div><div class="line">      .flatMap(<span class="type">Option</span>.apply)  <span class="comment">// handle null value</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 尽管代码会长一些，但以下方法可读性更高</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAddress</span></span>(name: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = &#123;</div><div class="line">  <span class="keyword">if</span> (!database.contains(name)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">None</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  database(name).data.get(<span class="string">"address"</span>) <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Some</span>(<span class="literal">null</span>) =&gt; <span class="type">None</span>  <span class="comment">// handle null value</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Some</span>(addr) =&gt; <span class="type">Option</span>(addr)</div><div class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a><a name="concurrency">并发</a></h2><h3 id="Scala-concurrent-Map"><a href="#Scala-concurrent-Map" class="headerlink" title="Scala concurrent.Map"></a><a name="concurrency-scala-collection">Scala concurrent.Map</a></h3><p><strong>优先考虑使用 <code>java.util.concurrent.ConcurrentHashMap</code> 而非 <code>scala.collection.concurrent.Map</code></strong>。尤其是 <code>scala.collection.concurrent.Map</code> 中的 <code>getOrElseUpdate</code> 方法要慎用，它并非原子操作（这个问题在 Scala 2.11.16 中 fix 了：<a href="https://issues.scala-lang.org/browse/SI-7943" target="_blank" rel="external">SI-7943</a>）。由于我们做的所有项目都需要在 Scala 2.10 和 Scala 2.11 上使用，因此要避免使用 <code>scala.collection.concurrent.Map</code>。</p>
<h3 id="显式同步-vs-并发集合"><a href="#显式同步-vs-并发集合" class="headerlink" title="显式同步 vs 并发集合"></a><a name="concurrency-sync-vs-map">显式同步 vs 并发集合</a></h3><p>有 3 种推荐的方法来安全地并发访问共享状态。<strong>不要混用它们</strong>，因为这会使程序变得难以推理，并且可能导致死锁。</p>
<ul>
<li><p><code>java.util.concurrent.ConcurrentHashMap</code>：当所有的状态都存储在一个 map 中，并且有高程度的竞争时使用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> map = <span class="keyword">new</span> java.util.concurrent.<span class="type">ConcurrentHashMap</span>[<span class="type">String</span>, <span class="type">String</span>]</div></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.Collections.synchronizedMap</code>：使用情景：当所有状态都存储在一个 map 中，并且预期不存在竞争情况，但你仍想确保代码在并发下是安全的。如果没有竞争出现，JVM 的 JIT 编译器能够通过偏置锁（biased locking）移除同步开销。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> map = java.util.<span class="type">Collections</span>.synchronizedMap(<span class="keyword">new</span> java.util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>])</div></pre></td></tr></table></figure>
</li>
<li><p>通过同步所有临界区进行显式同步，可用于监视多个变量。与 2 相似，JVM 的 JIT 编译器能够通过偏置锁（biased locking）移除同步开销。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> count = <span class="number">0</span></div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> map = <span class="keyword">new</span> java.util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(key: <span class="type">String</span>, value: <span class="type">String</span>): <span class="type">Unit</span> = synchronized &#123;</div><div class="line">    map.put(key, value)</div><div class="line">    count += <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getCount</span></span>: <span class="type">Int</span> = synchronized &#123; count &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，对于 case 1 和 case 2，不要让集合的视图或迭代器从保护区域逃逸。这可能会以一种不明显的方式发生，比如：返回了 <code>Map.keySet</code> 或 <code>Map.values</code>。如果需要传递集合的视图或值，生成一份数据拷贝再传递。</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> map = java.util.<span class="type">Collections</span>.synchronizedMap(<span class="keyword">new</span> java.util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>])</div><div class="line"></div><div class="line"><span class="comment">// This is broken!</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">values</span></span>: <span class="type">Iterable</span>[<span class="type">String</span>] = map.values</div><div class="line"></div><div class="line"><span class="comment">// Instead, copy the elements</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">values</span></span>: <span class="type">Iterable</span>[<span class="type">String</span>] = map.synchronized &#123; <span class="type">Seq</span>(map.values: _*) &#125;</div></pre></td></tr></table></figure>
<h3 id="显式同步-vs-原子变量-vs-volatile"><a href="#显式同步-vs-原子变量-vs-volatile" class="headerlink" title="显式同步 vs 原子变量 vs @volatile"></a><a name="concurrency-sync-vs-atomic">显式同步 vs 原子变量 vs @volatile</a></h3><p><code>java.util.concurrent.atomic</code> 包提供了对基本类型的无锁访问，比如：<code>AtomicBoolean</code>, <code>AtomicInteger</code> 和 <code>AtomicReference</code>。</p>
<p>始终优先考虑使用原子变量而非 <code>@volatile</code>，它们是相关功能的严格超集并且从代码上看更加明显。原子变量的底层实现使用了 <code>@volatile</code>。</p>
<p>优先考虑使用原子变量而非显式同步的情况：（1）一个对象的所有临界区更新都被限制在单个变量里并且预期会有竞争情况出现。原子变量是无锁的并且允许更为有效的竞争。（2）同步被明确地表示为 <code>getAndSet</code> 操作。例如：</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good: 明确又有效地表达了下面的并发代码只执行一次</span></div><div class="line"><span class="keyword">val</span> initialized = <span class="keyword">new</span> <span class="type">AtomicBoolean</span>(<span class="literal">false</span>)</div><div class="line">...</div><div class="line"><span class="keyword">if</span> (!initialized.getAndSet(<span class="literal">true</span>)) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// poor: 下面的同步就没那么明晰，而且会出现不必要的同步</span></div><div class="line"><span class="keyword">val</span> initialized = <span class="literal">false</span></div><div class="line">...</div><div class="line"><span class="keyword">var</span> wasInitialized = <span class="literal">false</span></div><div class="line">synchronized &#123;</div><div class="line">  wasInitialized = initialized</div><div class="line">  initialized = <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!wasInitialized) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="私有字段"><a href="#私有字段" class="headerlink" title="私有字段"></a><a name="concurrency-private-this">私有字段</a></h3><p>注意，<code>private</code> 字段仍然可以被相同类的其它实例所访问，所以仅仅通过 <code>this.synchronized</code>（或 <code>synchronized</code>）来保护它从技术上来说是不够的，不过你可以通过 <code>private[this]</code> 修饰私有字段来达到目的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以下代码仍然是不安全的。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> count: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(): <span class="type">Unit</span> = synchronized &#123; count += <span class="number">1</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 以下代码是安全的。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> count: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(): <span class="type">Unit</span> = synchronized &#123; count += <span class="number">1</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a><a name="concurrency-isolation">隔离</a></h3><p>一般来说，并发和同步逻辑应该尽可能地被隔离和包含起来。这实际上意味着：</p>
<ul>
<li>避免在 API 层面、面向用户的方法以及回调中暴露同步原语。</li>
<li>对于复杂模块，创建一个小的内部模块来包含并发原语。</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a><a name="perf">性能</a></h2><p>对于你写的绝大多数代码，性能都不应该成为一个问题。然而，对于一些性能敏感的代码，以下有一些小建议：</p>
<h3 id="Microbenchmarks"><a href="#Microbenchmarks" class="headerlink" title="Microbenchmarks"></a><a name="perf-microbenchmarks">Microbenchmarks</a></h3><p>由于 Scala 编译器和 JVM JIT 编译器会对你的代码做许多神奇的事情，因此要写出一个好的微基准程序（microbenchmark）是极其困难的。更多的情况往往是你的微基准程序并没有测量你想要测量的东西。</p>
<p>如果你要写一个微基准程序，请使用 <a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="external">jmh</a>。请确保你阅读了<a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/" target="_blank" rel="external">所有的样例</a>，这样你才理解微基准程序中「死代码」移除、常量折叠以及循环展开的效果。</p>
<h3 id="Traversal-与-zipWithIndex"><a href="#Traversal-与-zipWithIndex" class="headerlink" title="Traversal 与 zipWithIndex"></a><a name="perf-whileloops">Traversal 与 zipWithIndex</a></h3><p>使用 <code>while</code> 循环而非 <code>for</code> 循环或函数变换（如：<code>map</code>、<code>foreach</code>），for 循环和函数变换非常慢（由于虚函数调用和装箱的缘故）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">val</span> arr = <span class="comment">// array of ints</span></div><div class="line"><span class="comment">// 偶数位置的数置零</span></div><div class="line"><span class="keyword">val</span> newArr = list.zipWithIndex.map &#123; <span class="keyword">case</span> (elem, i) =&gt;</div><div class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> elem</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这是上面代码的高性能版本</span></div><div class="line"><span class="keyword">val</span> newArr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](arr.length)</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line"><span class="keyword">val</span> len = newArr.length</div><div class="line"><span class="keyword">while</span> (i &lt; len) &#123;</div><div class="line">  newArr(i) = <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> arr(i)</div><div class="line">  i += <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Option-与-null"><a href="#Option-与-null" class="headerlink" title="Option 与 null"></a><a name="perf-option">Option 与 null</a></h3><p>对于性能有要求的代码，优先考虑使用 <code>null</code> 而不是 <code>Option</code>，以此避免虚函数调用以及装箱操作。用 Nullable 注解明确标示出可能为 <code>null</code> 的值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="meta">@javax</span>.annotation.<span class="type">Nullable</span></div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> nullableField: <span class="type">Bar</span> = _</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Scala-集合库"><a href="#Scala-集合库" class="headerlink" title="Scala 集合库"></a><a name="perf-collection">Scala 集合库</a></h3><p>对于性能有要求的代码，优先考虑使用 Java 集合库而非 Scala 集合库，因为一般来说，Scala 集合库要比 Java 的集合库慢。</p>
<h3 id="private-this"><a href="#private-this" class="headerlink" title="private[this]"></a><a name="perf-private">private[this]</a></h3><p>对于性能有要求的代码，优先考虑使用 <code>private[this]</code> 而非 <code>private</code>。<code>private[this]</code> 生成一个字段而非生成一个访问方法。根据我们的经验，JVM JIT 编译器并不总是会内联 <code>private</code> 字段的访问方法，因此通过使用<br><code>private[this]</code> 来确保没有虚函数调用会更保险。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> field1 = ...</div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> field2 = ...</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perfSensitiveMethod</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> (i &lt; <span class="number">1000000</span>) &#123;</div><div class="line">      field1  <span class="comment">// This might invoke a virtual method call</span></div><div class="line">      field2  <span class="comment">// This is just a field access</span></div><div class="line">      i += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="与-Java-的互操作性"><a href="#与-Java-的互操作性" class="headerlink" title="与 Java 的互操作性"></a><a name="java">与 Java 的互操作性</a></h2><p>本节内容介绍的是构建 Java 兼容 API 的准则。如果你构建的组件并不需要与 Java 有交互，那么请无视这一节。这一节的内容主要是从我们开发 Spark 的 Java API 的经历中得出的。</p>
<h3 id="Scala-中缺失的-Java-特性"><a href="#Scala-中缺失的-Java-特性" class="headerlink" title="Scala 中缺失的 Java 特性"></a><a name="java-missing-features">Scala 中缺失的 Java 特性</a></h3><p>以下的 Java 特性在 Scala 中是没有的，如果你需要使用以下特性，请在 Java 中定义它们。然而，需要提醒一点的是，你无法为 Java 源文件生成 ScalaDoc。</p>
<ul>
<li>静态字段</li>
<li>静态内部类</li>
<li>Java 枚举</li>
<li>注解</li>
</ul>
<h3 id="Traits-与抽象类"><a href="#Traits-与抽象类" class="headerlink" title="Traits 与抽象类"></a><a name="java-traits">Traits 与抽象类</a></h3><p>对于允许从外部实现的接口，请记住以下几点：</p>
<ul>
<li>包含了默认方法实现的 trait 是无法在 Java 中使用的，请使用抽象类来代替。</li>
<li>一般情况下，请避免使用 trait，除非你百分百确定这个接口即使在未来也不会有默认的方法实现。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以下默认实现无法在 Java 中使用</span></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Listener</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onTermination</span></span>(): <span class="type">Unit</span> = &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 可以在 Java 中使用</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onTermination</span></span>(): <span class="type">Unit</span> = &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a><a name="java-type-alias">类型别名</a></h3><p>不要使用类型别名，它们在字节码和 Java 中是不可见的。</p>
<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><a name="java-default-param-values">默认参数值</a></h3><p>不要使用默认参数值，通过重载方法来代替。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 打破了与 Java 的互操作性</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(ratio: <span class="type">Double</span>, withReplacement: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">T</span>] = &#123; ... &#125;</div><div class="line"></div><div class="line"><span class="comment">// 以下方法是 work 的</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(ratio: <span class="type">Double</span>, withReplacement: <span class="type">Boolean</span>): <span class="type">RDD</span>[<span class="type">T</span>] = &#123; ... &#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(ratio: <span class="type">Double</span>): <span class="type">RDD</span>[<span class="type">T</span>] = sample(ratio, withReplacement = <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<h3 id="多参数列表-1"><a href="#多参数列表-1" class="headerlink" title="多参数列表"></a><a name="java-multi-param-list">多参数列表</a></h3><p>不要使用多参数列表。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><a name="java-varargs">可变参数</a></h3><ul>
<li><p>为可变参数方法添加 <code>@scala.annotation.varargs</code> 注解，以确保它能在 Java 中使用。Scala 编译器会生成两个方法，一个给 Scala 使用（字节码参数是一个 Seq），另一个给 Java 使用（字节码参数是一个数组）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@scala</span>.annotation.varargs</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(exprs: <span class="type">Expression</span>*): <span class="type">DataFrame</span> = &#123; ... &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>需要注意的一点是，由于 Scala 编译器的一个 bug（<a href="https://issues.scala-lang.org/browse/SI-1459" target="_blank" rel="external">SI-1459</a>，<a href="https://issues.scala-lang.org/browse/SI-9013" target="_blank" rel="external">SI-9013</a>），抽象的变参方法是无法在 Java 中使用的。</p>
</li>
<li><p>重载变参方法时要小心，用另一个类型去重载变参方法会破坏源码的兼容性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</div><div class="line">  <span class="meta">@scala</span>.annotation.varargs</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(elems: <span class="type">String</span>*): <span class="type">Unit</span> = ...</div><div class="line"></div><div class="line">  <span class="comment">// 当调用无参的 remove 方法时会出问题。</span></div><div class="line">  <span class="meta">@scala</span>.annotation.varargs</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(elems: <span class="type">People</span>*): <span class="type">Unit</span> = ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// remove 方法有歧义，因此编译不过。</span></div><div class="line"><span class="keyword">new</span> <span class="type">Database</span>().remove()</div></pre></td></tr></table></figure>
<p>一种解决方法是，在可变参数前显式地定义第一个参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</div><div class="line">  <span class="meta">@scala</span>.annotation.varargs</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(elems: <span class="type">String</span>*): <span class="type">Unit</span> = ...</div><div class="line"></div><div class="line">  <span class="comment">// 以下重载是 OK 的。</span></div><div class="line">  <span class="meta">@scala</span>.annotation.varargs</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(elem: <span class="type">People</span>, elems: <span class="type">People</span>*): <span class="type">Unit</span> = ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Implicits-1"><a href="#Implicits-1" class="headerlink" title="Implicits"></a><a name="java-implicits">Implicits</a></h3><p>不要为类或方法使用 implicit，包括了不要使用 <code>ClassTag</code> 和 <code>TypeTag</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaFriendlyAPI</span> </span>&#123;</div><div class="line">  <span class="comment">// 以下定义对 Java 是不友好的，因为方法中包含了一个隐式参数（ClassTag）。</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convertTo</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](): <span class="type">T</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="伴生对象，静态方法与字段"><a href="#伴生对象，静态方法与字段" class="headerlink" title="伴生对象，静态方法与字段"></a><a name="java-companion-object">伴生对象，静态方法与字段</a></h3><p>当涉及到伴生对象和静态方法/字段时，有几件事情是需要注意的：</p>
<ul>
<li><p>伴生对象在 Java 中的使用是非常别扭的（伴生对象 <code>Foo</code> 会被定义为 <code>Foo$</code> 类内的一个类型为 <code>Foo$</code> 的静态字段 <code>MODULE$</code>）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Foo</span></span></div><div class="line"></div><div class="line"><span class="comment">// 等价于以下的 Java 代码</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Foo$</span> </span>&#123;</div><div class="line">  <span class="type">Foo</span>$ <span class="type">MODULE</span>$ = <span class="comment">// 对象的实例化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果非要使用伴生对象，可以在一个单独的类中创建一个 Java 静态字段。</p>
</li>
<li><p>不幸的是，没有办法在 Scala 中定义一个 JVM 静态字段。请创建一个 Java 文件来定义它。</p>
</li>
<li><p>伴生对象里的方法会被自动转成伴生类里的静态方法，除非方法名有冲突。确保静态方法正确生成的最好方式是用 Java 写一个测试文件，然后调用生成的静态方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method2</span></span>(): <span class="type">Unit</span> = &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method1</span></span>(): <span class="type">Unit</span> = &#123; ... &#125;  <span class="comment">// 静态方法 Foo.method1 会被创建（字节码）</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method2</span></span>(): <span class="type">Unit</span> = &#123; ... &#125;  <span class="comment">// 静态方法 Foo.method2 不会被创建</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FooJavaTest.java (in test/scala/com/databricks/...)</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FooJavaTest</span> </span>&#123;</div><div class="line">  public static void compileTest() &#123;</div><div class="line">    <span class="type">Foo</span>.method1();  <span class="comment">// 正常编译</span></div><div class="line">    <span class="type">Foo</span>.method2();  <span class="comment">// 编译失败，因为 method2 并没有生成</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>样例对象（case object） MyClass 的类型并不是 MyClass。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">MyClass</span></span></div><div class="line"></div><div class="line"><span class="comment">// Test.java</span></div><div class="line"><span class="keyword">if</span> (<span class="type">MyClass</span>$.<span class="type">MODULE</span> instanceof <span class="type">MyClass</span>) &#123;</div><div class="line">  <span class="comment">// 上述条件始终为 false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现正确的类型层级结构，请定义一个伴生类，然后用一个样例对象去继承它：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><a name="misc">其它</a></h2><h3 id="优先使用-nanoTime-而非-currentTimeMillis"><a href="#优先使用-nanoTime-而非-currentTimeMillis" class="headerlink" title="优先使用 nanoTime 而非 currentTimeMillis"></a><a name="misc_currentTimeMillis_vs_nanoTime">优先使用 nanoTime 而非 currentTimeMillis</a></h3><p>当要计算<em>持续时间</em>或者检查<em>超时</em>的时候，避免使用 <code>System.currentTimeMillis()</code>。请使用 <code>System.nanoTime()</code>，即使你对亚毫秒级的精度并不感兴趣。</p>
<p><code>System.currentTimeMillis()</code> 返回的是当前的时钟时间，并且会跟进系统时钟的改变。因此，负的时钟调整可能会导致超时而挂起很长一段时间（直到时钟时间赶上先前的值）。这种情况可能发生在网络已经中断一段时间，ntpd 走过了一步之后。最典型的例子是，在系统启动的过程中，DHCP 花费的时间要比平常的长。这可能会导致非常难以理解且难以重现的问题。而 <code>System.nanoTime()</code> 则可以保证是单调递增的，与时钟变化无关。</p>
<p>注意事项：</p>
<ul>
<li>永远不要序列化一个绝对的 <code>nanoTime()</code> 值或是把它传递给另一个系统。绝对的 <code>nanoTime()</code> 值是无意义的、与系统相关的，并且在系统重启时会重置。</li>
<li>绝对的 <code>nanoTime()</code> 值并不保证总是正数（但 <code>t2 - t1</code> 能确保总是产生正确的值）。</li>
<li><code>nanoTime()</code> 每 292 年就会重新计算起。所以，如果你的 Spark 任务需要花非常非常非常长的时间，你可能需要别的东西来处理了：）</li>
</ul>
<h3 id="优先使用-URI-而非-URL"><a href="#优先使用-URI-而非-URL" class="headerlink" title="优先使用 URI 而非 URL"></a><a name="misc_uri_url">优先使用 URI 而非 URL</a></h3><p>当存储服务的 URL 时，你应当使用 <code>URI</code> 来表示。</p>
<p><code>URL</code> 的<a href="http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object" target="_blank" rel="external">相等性检查</a>)实际上执行了一次网络调用（这是阻塞的）来解析 IP 地址。<code>URI</code> 类在表示能力上是 <code>URL</code> 的超集，并且它执行的是字段的相等性检查。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><a name="unit-test">单元测试</a></h2><h3 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a><a name="unit-test-framework">单元测试框架</a></h3><p>ScalaTest几乎已经成为Scala语言默认的测试框架，这主要源于它提供了多种表达力超强的测试风格，能够满足各种层次的需求包括单元测试、BDD、验收测试、数据驱动测试。我们也使用<a href="http://www.scalatest.org/" target="_blank" rel="external">ScalaTest</a>测试框架。使用的时候在<code>pom.xml</code>中添加如下类似引用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- test: https://mvnrepository.com/artifact/org.scalatest/scalatest_2.10 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scalatest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scalatest_2.10<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>测试我们遵循以下几点规则：</p>
<ul>
<li>测试类应该与被测试类处于同一包下，测试类的命名为：被测试类名 + Test</li>
<li>测试含有具体实现的trait时，可以让被测试类直接继承Trait。例如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RecordsGenerator</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">generateRecords</span></span>(table: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]): <span class="type">List</span>[<span class="type">Record</span>] &#123;</div><div class="line">          <span class="comment">//...</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordsGeneratorSpec</span> <span class="keyword">extends</span> <span class="title">FlatSpec</span> <span class="keyword">with</span> <span class="title">ShouldMatcher</span> <span class="keyword">with</span> <span class="title">RecordGenerator</span> </span>&#123;</div><div class="line">     <span class="keyword">val</span> table = <span class="type">List</span>(<span class="type">List</span>(<span class="string">"abc"</span>, <span class="string">"def"</span>), <span class="type">List</span>(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>))</div><div class="line">     it should <span class="string">"generate records"</span> in &#123;</div><div class="line">          <span class="keyword">val</span> records = generateRecords(table)</div><div class="line">          records.size should be(<span class="number">2</span>)</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>若要对文件进行测试，可以用字符串假装文件：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">CsvLine</span> </span>= <span class="type">String</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatCsv</span></span>(source: <span class="type">Source</span>): <span class="type">List</span>[<span class="type">CsvLine</span>] = &#123;</div><div class="line">     source.getLines(_.replace(<span class="string">", "</span>, <span class="string">"|"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>formatCsv需要接受一个文件源，例如Source.fromFile(“testdata.txt”)。但在测试时，可以通过Source.fromString方法来生成formatCsv需要接收的Source对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test(<span class="string">"format csv lines"</span>) &#123;</div><div class="line">     <span class="keyword">val</span> lines = <span class="type">Source</span>.fromString(<span class="string">"abc, def, hgi\n1, 2, 3\none, two, three"</span>)</div><div class="line">     <span class="keyword">val</span> result = formatCsv(lines)</div><div class="line">     assert(result.mkString(<span class="string">"\n"</span>).equles(<span class="string">"abc|def|hgi\n1|2|3\none|two|three"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="测试风格的选择"><a href="#测试风格的选择" class="headerlink" title="测试风格的选择"></a><a name="unit-test-style">测试风格的选择</a></h3><p>ScalaTest一共提供了七种测试风格，分别为：FunSuite，FlatSpec，FunSpec，WordSpec，FreeSpec，PropSpec和FeatureSpec。这就好像使用相同的原料做成不同美味乃至不同菜系的佳肴，你可以根据自己的口味进行选择。我们统一推荐使用FunSuite的方式，因为它更灵活，而且更符合传统测试方法的风格，区别仅在于test()方法可以接受一个闭包:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.scalatest.<span class="type">FunSuite</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetSuite</span> <span class="keyword">extends</span> <span class="title">FunSuite</span> </span>&#123;</div><div class="line"></div><div class="line">  test(<span class="string">"An empty Set should have size 0"</span>) &#123;</div><div class="line">    assert(<span class="type">Set</span>.empty.size == <span class="number">0</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  test(<span class="string">"Invoking head on an empty Set should produce NoSuchElementException"</span>) &#123;</div><div class="line">    assertThrows[<span class="type">NoSuchElementException</span>] &#123;</div><div class="line">      <span class="type">Set</span>.empty.head</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，如果你有必须的理由选择其它测试风格的话，本规则并不强制。</p>
<h1 id="三、-引用"><a href="#三、-引用" class="headerlink" title="三、 引用"></a>三、 引用</h1><p><a href="https://github.com/databricks/scala-style-guide/blob/master/README-ZH.md" target="_blank" rel="external">Databricks Scala 编程风格指南</a>(团队最终选择的模板)<br><a href="http://twitter.github.io/effectivescala/index-cn.html" target="_blank" rel="external">Effective Scala</a>(Twitter Scala资料，值得参考)<br><a href="https://zhangyi.gitbooks.io/thinking-in-scala/content/scala-convention.html" target="_blank" rel="external">Thinking in Scala–Scala编程规范</a>(个人整理，可以参考)<br><a href="http://www.scala-lang.org/docu/files/Scala%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83.pdf" target="_blank" rel="external">scala-lang–Scala语言规范.pdf</a>(官方原版的中文文档，共127页，过于复杂琐碎，可以参考)<br><a href="http://docs.scala-lang.org/style/" target="_blank" rel="external">Scala官网Style Guide</a>(官方原版，其它版本基本上都是基于此版进行的改进)<br><a href="https://segmentfault.com/a/1190000000420018" target="_blank" rel="external">分析GitHub上托管的scala开源代码统计</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://flume.cn/2017/01/09/大数据团队scala代码规范/" data-id="cjgd2byf10024eggujht1cljx" class="article-share-link">分享</a><div class="tags"><a href="/tags/scala/">scala</a></div><div class="post-nav"><a href="/2017/02/24/Livy-server的搭建与简单测试/" class="pre">Livy-server的搭建与简单测试</a><a href="/2017/01/03/Spark源码阅读之——StreamingContext详解/" class="next">Spark源码阅读之——StreamingContext详解</a></div><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2139407"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/eagle/">eagle</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark开发/">spark开发</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring-cloud/">spring cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/单车岁月/">单车岁月</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/大数据开发/" style="font-size: 15px;">大数据开发</a> <a href="/tags/scala/" style="font-size: 15px;">scala</a> <a href="/tags/hue/" style="font-size: 15px;">hue</a> <a href="/tags/kerberos/" style="font-size: 15px;">kerberos</a> <a href="/tags/livy/" style="font-size: 15px;">livy</a> <a href="/tags/hbase/" style="font-size: 15px;">hbase</a> <a href="/tags/yarn/" style="font-size: 15px;">yarn</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/flume/" style="font-size: 15px;">flume</a> <a href="/tags/spark-streaming/" style="font-size: 15px;">spark streaming</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/持续更新/" style="font-size: 15px;">持续更新</a> <a href="/tags/spark开发/" style="font-size: 15px;">spark开发</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/散文/" style="font-size: 15px;">散文</a> <a href="/tags/eagle/" style="font-size: 15px;">eagle</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/spring-cloud/" style="font-size: 15px;">spring cloud</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/es/" style="font-size: 15px;">es</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/08/spark2-2新版本编译打包/">spark2.2新版本编译打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/使用Ansable安装管理Spark客户端/">使用Ansable安装管理Spark客户端</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/spark往ES中写入数据的方法/">spark往ES中写入数据的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/spark指定java版本向yarn提交程序/">spark在yarn中运行jdk8</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/返回区域实时人数的思路与总结/">返回区域实时人数的思路与总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/位置服务开发上线总结/">位置服务开发上线总结————实时数据推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/spark奇技淫巧总结之flatMap/">spark奇技淫巧总结之强大的flatMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/OpenAPI微服务接入规范/">OpenAPI微服务接入规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/29/OpenApi之我浅薄见解/">OpenApi之我浅薄见解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/24/阿里巴巴Java开发手册学习笔记2/">阿里巴巴Java开发手册学习笔记（下）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://issues.apache.org/jira/secure/Dashboard.jspa" title="有问题上JIRA" target="_blank">有问题上JIRA</a><ul></ul><a href="https://github.com/lw-lin/CoolplaySpark" title="酷玩 Spark" target="_blank">酷玩 Spark</a><ul></ul><a href="http://lqding.blog.51cto.com" title="叮咚的51博客" target="_blank">叮咚的51博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Adam Home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
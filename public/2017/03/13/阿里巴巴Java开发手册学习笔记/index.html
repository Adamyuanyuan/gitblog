<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>阿里巴巴Java开发手册学习笔记（上） | Adam Home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">阿里巴巴Java开发手册学习笔记（上）</h1><a id="logo" href="/.">Adam Home</a><p class="description">快意回首，拂心莫停</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于我</i></a><a href="/timeline/"><i class="fa fa-line-chart"> 历史</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">阿里巴巴Java开发手册学习笔记（上）</h1><div class="post-meta">Mar 13, 2017<span> | </span><span class="category"><a href="/categories/java/">java</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>本人自认为代码还算写得比较符合规范，但是相信阿里会有总结更深的见解，因此对自己之前没有注意到的，自己没有遵循的，做一个笔记与整理，以加深理解。</p>
<h1 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h1><h2 id="命名规约"><a href="#命名规约" class="headerlink" title="命名规约"></a>命名规约</h2><h4 id="【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"><a href="#【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。" class="headerlink" title="【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"></a>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</h4><p>重点在，不要嫌名字长，我以前写得比较短<br>正例： <code>MAX _ STOCK _ COUNT</code></p>
<h4 id="【强制】抽象类命名使用-Abstract-或-Base-开头-；-异常类命名使用-Exception-结尾-；-测试类命名以它要测试的类的名称开始，以-Test-结尾。"><a href="#【强制】抽象类命名使用-Abstract-或-Base-开头-；-异常类命名使用-Exception-结尾-；-测试类命名以它要测试的类的名称开始，以-Test-结尾。" class="headerlink" title="【强制】抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类命名以它要测试的类的名称开始，以 Test 结尾。"></a>【强制】抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类命名以它要测试的类的名称开始，以 Test 结尾。</h4><p>如果是接口的话，如何？</p>
<h4 id="接口和实现类的命名有两套规则"><a href="#接口和实现类的命名有两套规则" class="headerlink" title="接口和实现类的命名有两套规则"></a>接口和实现类的命名有两套规则</h4><blockquote>
<p>1 ） 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部<br>的实现类用 Impl 的后缀与接口区别。<br>正例： CacheServiceImpl 实现 CacheService 接口。<br>2 ）  【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名 （ 通常是– able 的形式 ） 。<br>正例： AbstractTranslator 实现  Translatable 。</p>
</blockquote>
<p>一定注意，之前写scala的时候，并没有考虑到这一点，DAO和Service暴露出来一定是接口，然后用Impl后缀的实现类实现。</p>
<h4 id="【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。"><a href="#【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。" class="headerlink" title="【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。"></a>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</h4><blockquote>
<p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字： DealStatusEnum， 成员名称： SUCCESS /  UNKOWN _ REASON 。</p>
</blockquote>
<h4 id="【强制】-POJO-类中布尔类型的变量，都不要加-is-，否则部分框架解析会引起序列化错误。"><a href="#【强制】-POJO-类中布尔类型的变量，都不要加-is-，否则部分框架解析会引起序列化错误。" class="headerlink" title="【强制】 POJO 类中布尔类型的变量，都不要加 is ，否则部分框架解析会引起序列化错误。"></a>【强制】 POJO 类中布尔类型的变量，都不要加 is ，否则部分框架解析会引起序列化错误。</h4><blockquote>
<p>反例：定义为基本数据类型 boolean isSuccess； 的属性，它的方法也是 isSuccess() ， RPC<br>框架在反向解析的时候，“以为”对应的属性名称是 success ，导致属性获取不到，进而抛出异<br>常。</p>
</blockquote>
<h4 id="【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。"><a href="#【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。" class="headerlink" title="【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。"></a>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</h4><p>点分隔符之间仅有一个自然语义的英语单词，包名统一使用单数形式，但类名可以使用复数形式</p>
<h4 id="【强制】杜绝完全不规范的缩写，避免望文不知义"><a href="#【强制】杜绝完全不规范的缩写，避免望文不知义" class="headerlink" title="【强制】杜绝完全不规范的缩写，避免望文不知义"></a>【强制】杜绝完全不规范的缩写，避免望文不知义</h4><blockquote>
<p>反例：  AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成  condi ，此类<br>随意缩写严重降低了代码的可阅读性。</p>
</blockquote>
<p>的确是，一定要注意</p>
<h4 id="【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"><a href="#【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。" class="headerlink" title="【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"></a>【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。</h4><blockquote>
<p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br>正例： public class OrderFactory;<br>public class LoginProxy;<br>public class ResourceObserver;</p>
</blockquote>
<h4 id="【参考】各层命名规约："><a href="#【参考】各层命名规约：" class="headerlink" title="【参考】各层命名规约："></a>【参考】各层命名规约：</h4><blockquote>
<p>A) Service / DAO 层方法命名规约<br>1 ） 获取单个对象的方法用 get 做前缀。<br>2 ） 获取多个对象的方法用 list 做前缀。<br>3 ） 获取统计值的方法用 count 做前缀。<br>4 ） 插入的方法用 save（ 推荐 ） 或 insert 做前缀。<br>5 ） 删除的方法用 remove（ 推荐 ） 或 delete 做前缀。<br>6 ） 修改的方法用 update 做前缀。<br>B) 领域模型命名规约<br>1 ） 数据对象： xxxDO ， xxx 即为数据表名。<br>2 ） 数据传输对象： xxxDTO ， xxx 为业务领域相关的名称。<br>3 ） 展示对象： xxxVO ， xxx 一般为网页名称。<br>4 ） POJO 是 DO / DTO / BO / VO 的统称，禁止命名成 xxxPOJO 。</p>
</blockquote>
<p>到时候命名的时候再查阅一遍</p>
<h4 id="【推荐】接口类中的方法和属性不要加任何修饰符号-（public-也不要加-）-，保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。"><a href="#【推荐】接口类中的方法和属性不要加任何修饰符号-（public-也不要加-）-，保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。" class="headerlink" title="【推荐】接口类中的方法和属性不要加任何修饰符号 （public 也不要加 ） ，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。"></a>【推荐】接口类中的方法和属性不要加任何修饰符号 （public 也不要加 ） ，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</h4><blockquote>
<p>正例：接口方法签名： void f();<br>接口基础常量表示： String COMPANY = “ alibaba “ ;<br>反例：接口方法定义： public abstract void f();<br>说明： JDK 8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。</p>
</blockquote>
<p>定义接口的时候，方法和属性，不要加任何修饰符号，注释要写清楚</p>
<h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><h4 id="【强制】不允许出现任何魔法值-（-即未经定义的常量-）-直接出现在代码中。"><a href="#【强制】不允许出现任何魔法值-（-即未经定义的常量-）-直接出现在代码中。" class="headerlink" title="【强制】不允许出现任何魔法值 （ 即未经定义的常量 ） 直接出现在代码中。"></a>【强制】不允许出现任何魔法值 （ 即未经定义的常量 ） 直接出现在代码中。</h4><p>反例：  String key =”Id#taobao_”+ tradeId；<br>cache . put(key ,  value);</p>
<p>为什么要这样做？</p>
<h4 id="如果变量值仅在一个范围内变化用-Enum-类。如果还带有名称之外的延伸属性，必须使用-Enum-类，下面正例中的数字就是延伸信息，表示星期几。"><a href="#如果变量值仅在一个范围内变化用-Enum-类。如果还带有名称之外的延伸属性，必须使用-Enum-类，下面正例中的数字就是延伸信息，表示星期几。" class="headerlink" title="如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类，下面正例中的数字就是延伸信息，表示星期几。"></a>如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类，下面正例中的数字就是延伸信息，表示星期几。</h4><p>正例： public Enum {  MONDAY( 1 ) ,  TUESDAY( 2 ) ,  WEDNESDAY( 3 ) ,  THURSDAY( 4 ) ,  FRIDAY( 5 ) ,SATURDAY( 6 ) ,  SUNDAY( 7 ); }</p>
<h2 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h2><h4 id="【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则："><a href="#【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则：" class="headerlink" title="【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则："></a>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</h4><p>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>2 ） 运算符与下文一起换行。<br>3 ） 方法调用的点符号与下文一起换行。<br>4 ） 在多个参数超长，逗号后进行换行。<br>5 ） 在括号前不要换行，见反例。</p>
<p>我之前是不能超过90个，目的是笔记本电脑看代码的时候比较方便，现在涨到120个了</p>
<h4 id="【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。"><a href="#【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。" class="headerlink" title="【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。"></a>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。</h4><p>说明：没有必要插入多行空格进行隔开。不能有多插几行的强迫症</p>
<h2 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h2><h4 id="【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。"><a href="#【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。" class="headerlink" title="【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。"></a>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</h4><h4 id="【强制】所有的覆写方法，必须加-Override-注解。"><a href="#【强制】所有的覆写方法，必须加-Override-注解。" class="headerlink" title="【强制】所有的覆写方法，必须加 @Override 注解。"></a>【强制】所有的覆写方法，必须加 @Override 注解。</h4><p>反例： getObject() 与 get0bject() 的问题。一个是字母的 O ，一个是数字的 0，加@Override<br>可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编<br>译报错。</p>
<h4 id="【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object-。"><a href="#【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object-。" class="headerlink" title="【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。"></a>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。</h4><p>说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）<br>正例： public User getUsers(String type, Integer… ids)</p>
<h4 id="【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。"><a href="#【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。" class="headerlink" title="【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。"></a>【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。</h4><p>接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p>
<h4 id="【强制】不能使用过时的类或方法。"><a href="#【强制】不能使用过时的类或方法。" class="headerlink" title="【强制】不能使用过时的类或方法。"></a>【强制】不能使用过时的类或方法。</h4><h4 id="【强制】-Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals-。"><a href="#【强制】-Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals-。" class="headerlink" title="【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 。"></a>【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 。</h4><p>正例： “ test “ .equals(object);<br>反例：  object.equals( “ test “ );<br>说明：推荐使用 java . util . Objects # equals （JDK 7 引入的工具类 ）</p>
<h4 id="【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。"><a href="#【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。" class="headerlink" title="【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。"></a>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。</h4><p>说明：对于 Integer var =?在-128 至 127 之间的赋值， Integer 对象是在<br>IntegerCache . cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行<br>判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，<br>推荐使用 equals 方法进行判断。</p>
<p>为什么这是个大坑？？？因为使用 == 比较的话，会判断内存地址是否相同，这样会返回False</p>
<h4 id="8-【强制】关于基本数据类型与包装数据类型的使用标准如下："><a href="#8-【强制】关于基本数据类型与包装数据类型的使用标准如下：" class="headerlink" title="8. 【强制】关于基本数据类型与包装数据类型的使用标准如下："></a>8. 【强制】关于基本数据类型与包装数据类型的使用标准如下：</h4><p>1 ） 所有的 POJO 类属性必须使用包装数据类型。<br>2 ） RPC 方法的返回值和参数必须使用包装数据类型。<br>3 ） 所有的局部变量【推荐】使用基本数据类型。</p>
<p>包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p>
<h4 id="【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。"><a href="#【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。" class="headerlink" title="【强制】定义 DO / DTO / VO 等 POJO 类时，不要设定任何属性默认值。"></a>【强制】定义 DO / DTO / VO 等 POJO 类时，不要设定任何属性默认值。</h4><p>反例： POJO 类的 gmtCreate 默认值为 new Date(); 但是这个属性在数据提取时并没有置入具<br>体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p>
<h4 id="【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。"><a href="#【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。" class="headerlink" title="【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。"></a>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</h4><h4 id="【强制】-POJO-类必须写-toString-方法。使用-IDE-的中工具：-source-gt-generate-toString时，如果继承了另一个-POJO-类，注意在前面加一下-super-toString-。"><a href="#【强制】-POJO-类必须写-toString-方法。使用-IDE-的中工具：-source-gt-generate-toString时，如果继承了另一个-POJO-类，注意在前面加一下-super-toString-。" class="headerlink" title="【强制】 POJO 类必须写 toString 方法。使用 IDE 的中工具： source &gt;  generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super . toString 。"></a>【强制】 POJO 类必须写 toString 方法。使用 IDE 的中工具： source &gt;  generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super . toString 。</h4><p>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString() 方法打印其属性值，便于排<br>查问题。</p>
<h4 id="【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。"><a href="#【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。" class="headerlink" title="【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。"></a>【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。</h4><p>说明：<br>String str = “a,b,c,,”;<br>String[] ary = str.split(“,”);<br>//预期大于 3，结果是 3<br>System.out.println(ary.length);</p>
<h4 id="【推荐】类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter方法。"><a href="#【推荐】类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter方法。" class="headerlink" title="【推荐】类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt;  getter / setter方法。"></a>【推荐】类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt;  getter / setter方法。</h4><p>说明：构造方法放到最前面，公有方法是类的调用者和维护者最关心的方法，首屏展示最好 ； 保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法 ； 而私有方法外部一般不需要特别关心，是一个黑盒实现 ； 因为方法信息价值较低，所有 Service 和 DAO 的 getter / setter 方法放在类体最后。</p>
<h4 id="【推荐】在getter-setter-方法中，尽量不要增加业务逻辑，增加排查问题的难度。"><a href="#【推荐】在getter-setter-方法中，尽量不要增加业务逻辑，增加排查问题的难度。" class="headerlink" title="【推荐】在getter / setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。"></a>【推荐】在getter / setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。</h4><h4 id="【推荐】循环体内，字符串的联接方式，使用-StringBuilder-的-append-方法进行扩展。"><a href="#【推荐】循环体内，字符串的联接方式，使用-StringBuilder-的-append-方法进行扩展。" class="headerlink" title="【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。"></a>【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。</h4><h4 id="【推荐】-final-可提高程序响应效率，声明成-final-的情况："><a href="#【推荐】-final-可提高程序响应效率，声明成-final-的情况：" class="headerlink" title="【推荐】 final 可提高程序响应效率，声明成 final 的情况："></a>【推荐】 final 可提高程序响应效率，声明成 final 的情况：</h4><p>1 ） 不需要重新赋值的变量，包括类属性、局部变量。<br>2 ） 对象参数前加 final ，表示不允许修改引用的指向。<br>3 ） 类方法确定不允许被重写。</p>
<h4 id="【推荐】慎用-Object-的-clone-方法来拷贝对象。"><a href="#【推荐】慎用-Object-的-clone-方法来拷贝对象。" class="headerlink" title="【推荐】慎用 Object 的 clone 方法来拷贝对象。"></a>【推荐】慎用 Object 的 clone 方法来拷贝对象。</h4><p>说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象<br>的拷贝。</p>
<h4 id="【推荐】类成员与方法访问控制从严："><a href="#【推荐】类成员与方法访问控制从严：" class="headerlink" title="【推荐】类成员与方法访问控制从严："></a>【推荐】类成员与方法访问控制从严：</h4><p>1 ） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private 。<br>2 ） 工具类不允许有 public 或 default 构造方法。<br>3 ） 类非 static 成员变量并且与子类共享，必须是 protected 。<br>4 ） 类非 static 成员变量并且仅在本类使用，必须是 private 。<br>5 ） 类 static 成员变量如果仅在本类使用，必须是 private 。<br>6 ） 若是 static 成员变量，必须考虑是否为 final 。<br>7 ） 类成员方法只供类内部调用，必须是 private 。<br>8 ） 类成员方法只对继承类公开，那么限制为 protected 。<br>说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。<br>思<br>考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一<br>个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视<br>线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。</p>
<p><strong>这一点是非常重要的习惯，一定要加以养成</strong></p>
<h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><h4 id="【强制】关于-hashCode-和-equals-的处理，遵循如下规则："><a href="#【强制】关于-hashCode-和-equals-的处理，遵循如下规则：" class="headerlink" title="【强制】关于 hashCode 和 equals 的处理，遵循如下规则："></a>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</h4><p>1） 只要重写 equals ，就必须重写 hashCode 。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的<br>对象必须重写这两个方法。<br>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals 。<br>正例： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象<br>作为 key 来使用。</p>
<h4 id="【强制】-ArrayList-的-subList-结果不可强转成-ArrayList-，否则会抛出-ClassCastException"><a href="#【强制】-ArrayList-的-subList-结果不可强转成-ArrayList-，否则会抛出-ClassCastException" class="headerlink" title="【强制】  ArrayList 的 subList 结果不可强转成 ArrayList ，否则会抛出 ClassCastException"></a>【强制】  ArrayList 的 subList 结果不可强转成 ArrayList ，否则会抛出 ClassCastException</h4><p>异常： java . util . RandomAccessSubList cannot be cast to java . util . ArrayList ;<br>说明： subList 返回的是  ArrayList 的内部类  SubList ，并不是  ArrayList ，而是<br>ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p>
<h4 id="【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生-ConcurrentModificationException-异常。"><a href="#【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生-ConcurrentModificationException-异常。" class="headerlink" title="【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常。"></a>【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常。</h4><h4 id="【强制】使用集合转数组的方法，必须使用集合的-toArray-T-array-，传入的是类型完全一样的数组，大小就是-list-size-。"><a href="#【强制】使用集合转数组的方法，必须使用集合的-toArray-T-array-，传入的是类型完全一样的数组，大小就是-list-size-。" class="headerlink" title="【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array) ，传入的是类型完全一样的数组，大小就是 list . size() 。"></a>【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array) ，传入的是类型完全一样的数组，大小就是 list . size() 。</h4><p>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[] 类，若强转其它<br>类型数组将出现 ClassCastException 错误。<br>正例：<br>List<string> list = new ArrayList<string>(2);<br>list.add(“guan”);<br>list.add(“bao”);<br>String[] array = new String[list.size()];<br>array = list.toArray(array);<br>说明：使用 toArray 带参方法，入参分配的数组空间不够大时， toArray 方法内部将重新分配<br>内存空间，并返回新数组地址 ； 如果数组元素大于实际所需，下标为 [ list . size() ] 的数组<br>元素将被置为 null ，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素<br>个数一致。</string></string></p>
<p>toArray 方法，一定要带参数，指定类型和大小；</p>
<h4 id="【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。"><a href="#【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。" class="headerlink" title="【强制】使用工具类 Arrays . asList() 把数组转换成集合时，不能使用其修改集合相关的方法，它的 add / remove / clear 方法会抛出 UnsupportedOperationException 异常。"></a>【强制】使用工具类 Arrays . asList() 把数组转换成集合时，不能使用其修改集合相关的方法，它的 add / remove / clear 方法会抛出 UnsupportedOperationException 异常。</h4><p>说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Arrays . asList<br>体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br>String[] str = new String[] { “a”, “b” };<br>List list = Arrays.asList(str);<br>第一种情况： list.add(“c”);  运行时异常。<br>第二种情况： str[0]= “gujin”; 那么 list.get(0) 也会随之修改。</p>
<h4 id="【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法。"><a href="#【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法。" class="headerlink" title="【强制】泛型通配符&lt;?  extends T &gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。"></a>【强制】泛型通配符&lt;?  extends T &gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。</h4><p>说明：苹果装箱后返回一个<code>&lt;?  extends Fruits &gt;</code> 对象，此对象就不能往里加任何水果，包括苹果。</p>
<h4 id="【强制】不要在-foreach-循环里进行元素的-remove-add-操作。-remove-元素请使用-Iterator方式，如果并发操作，需要对-Iterator-对象加锁。"><a href="#【强制】不要在-foreach-循环里进行元素的-remove-add-操作。-remove-元素请使用-Iterator方式，如果并发操作，需要对-Iterator-对象加锁。" class="headerlink" title="【强制】不要在 foreach 循环里进行元素的 remove / add 操作。 remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。"></a>【强制】不要在 foreach 循环里进行元素的 remove / add 操作。 remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。</h4><p>这个坑我以前踩过，如果早点看到就不会踩到了。。。</p>
<h4 id="【强制】-在-JDK-7-版本以上，-Comparator-要满足自反性，传递性，对称性，不然-Arrays-sort-，Collections-sort-会报-IllegalArgumentException-异常。"><a href="#【强制】-在-JDK-7-版本以上，-Comparator-要满足自反性，传递性，对称性，不然-Arrays-sort-，Collections-sort-会报-IllegalArgumentException-异常。" class="headerlink" title="【强制】 在 JDK 7 版本以上， Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort ，Collections.sort 会报 IllegalArgumentException 异常。"></a>【强制】 在 JDK 7 版本以上， Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort ，Collections.sort 会报 IllegalArgumentException 异常。</h4><p>说明：<br>1 ） 自反性： x ， y 的比较结果和 y ， x 的比较结果相反。<br>2 ） 传递性： x &gt; y , y &gt; z ,则 x &gt; z 。<br>3 ） 对称性： x = y ,则 x , z 比较结果和 y ， z 比较结果相同。</p>
<h4 id="【推荐】集合初始化时，尽量指定集合初始值大小。"><a href="#【推荐】集合初始化时，尽量指定集合初始值大小。" class="headerlink" title="【推荐】集合初始化时，尽量指定集合初始值大小。"></a>【推荐】集合初始化时，尽量指定集合初始值大小。</h4><p>说明： ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。</p>
<h4 id="【推荐】使用-entrySet-遍历-Map-类集合-KV-，而不是-keySet-方式进行遍历。"><a href="#【推荐】使用-entrySet-遍历-Map-类集合-KV-，而不是-keySet-方式进行遍历。" class="headerlink" title="【推荐】使用 entrySet 遍历 Map 类集合 KV ，而不是 keySet 方式进行遍历。"></a>【推荐】使用 entrySet 遍历 Map 类集合 KV ，而不是 keySet 方式进行遍历。</h4><p>说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value 。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK 8，使用 Map . foreach 方法。<br>正例： values() 返回的是 V 值集合，是一个 list 集合对象 ；keySet() 返回的是 K 值集合，是一个 Set 集合对象；entrySet() 返回的是 K - V 值组合集合。</p>
<h4 id="【推荐】高度注意-Map-类集合-K-V-能不能存储-null-值的情况，如下表格："><a href="#【推荐】高度注意-Map-类集合-K-V-能不能存储-null-值的情况，如下表格：" class="headerlink" title="【推荐】高度注意 Map 类集合 K / V 能不能存储 null 值的情况，如下表格："></a>【推荐】高度注意 Map 类集合 K / V 能不能存储 null 值的情况，如下表格：</h4><table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Super</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>AbstractMap</td>
<td>分段锁技术</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td>允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
</tbody>
</table>
<p>反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，注意存储null 值时会抛出 NPE 异常。</p>
<h4 id="【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。"><a href="#【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。" class="headerlink" title="【参考】合理利用好集合的有序性 (sort) 和稳定性 (order) ，避免集合的无序性 (unsort) 和不稳定性 (unorder) 带来的负面影响。"></a>【参考】合理利用好集合的有序性 (sort) 和稳定性 (order) ，避免集合的无序性 (unsort) 和不稳定性 (unorder) 带来的负面影响。</h4><p>说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则依次排列的。如： ArrayList 是 order / unsort；HashMap 是 unorder / unsort；TreeSet 是order / sort 。</p>
<h4 id="【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的contains-方法进行遍历、对比、去重操作。"><a href="#【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的contains-方法进行遍历、对比、去重操作。" class="headerlink" title="【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。"></a>【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。</h4><p>自评：这个好：使用 s.addAll(list); 方法。</p>
<h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><h4 id="【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"><a href="#【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。" class="headerlink" title="【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"></a>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h4><p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p>
<h4 id="【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"><a href="#【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。" class="headerlink" title="【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"></a>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>); ...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。"><a href="#【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。" class="headerlink" title="【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。"></a>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</h4><p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者<br>“过度切换”的问题。</p>
<h4 id="【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"><a href="#【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。" class="headerlink" title="【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"></a>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</h4><p>说明： Executors 返回的线程池对象的弊端如下：<br>1） FixedThreadPool 和 SingleThreadPool :<br>允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。<br>2） CachedThreadPool 和 ScheduledThreadPool :<br>允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。</p>
<h4 id="【强制】-SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static-，必须加锁，或者使用-DateUtils-工具类。"><a href="#【强制】-SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static-，必须加锁，或者使用-DateUtils-工具类。" class="headerlink" title="【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static ，必须加锁，或者使用 DateUtils 工具类。"></a>【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static ，必须加锁，或者使用 DateUtils 工具类。</h4><h4 id="【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁-；-能锁区块，就不要锁整个方法体-；-能用对象锁，就不要用类锁。"><a href="#【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁-；-能锁区块，就不要锁整个方法体-；-能用对象锁，就不要用类锁。" class="headerlink" title="【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁 ； 能锁区块，就不要锁整个方法体 ； 能用对象锁，就不要用类锁。"></a>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁 ； 能锁区块，就不要锁整个方法体 ； 能用对象锁，就不要用类锁。</h4><h4 id="【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁"><a href="#【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁" class="headerlink" title="【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁"></a>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁</h4><p>说明：线程一需要对表 A 、 B 、 C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序<br>也必须是 A 、 B 、 C ，否则可能出现死锁。</p>
<h4 id="【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。"><a href="#【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。" class="headerlink" title="【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。"></a>【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</h4><p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次<br>数不得小于 3 次。</p>
<h4 id="【强制】多线程并行处理定时任务时，-Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。"><a href="#【强制】多线程并行处理定时任务时，-Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。" class="headerlink" title="【强制】多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。"></a>【强制】多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</h4><p>都是经验啊，我还没有碰到这种坑</p>
<h4 id="【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown-方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行至-countDown-方法，直到超时才返回结果。"><a href="#【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown-方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行至-countDown-方法，直到超时才返回结果。" class="headerlink" title="【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。"></a>【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。</h4><p>说明：注意，子线程抛出异常堆栈，不能在主线程 try - catch 到。</p>
<h4 id="【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。"><a href="#【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。" class="headerlink" title="【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。"></a>【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。</h4><p>说明： Random 实例包括 java . util . Random 的实例或者  Math . random() 实例。<br>正例：在 JDK 7 之后，可以直接使用 API ThreadLocalRandom ，在  JDK 7 之前，可以做到每个<br>线程一个实例。</p>
<h4 id="【参考】-volatile-解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。"><a href="#【参考】-volatile-解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。" class="headerlink" title="【参考】 volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。"></a>【参考】 volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</h4><p>如果是 count ++操作，使用如下类实现：AtomicInteger count =  new AtomicInteger(); count . addAndGet( 1 );  如果是 JDK 8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好 （ 减少乐观锁的重试次数 ） 。</p>
<h4 id="【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。"><a href="#【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。" class="headerlink" title="【参考】  HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。"></a>【参考】  HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</h4><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h4 id="【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止-；-在一个-switch-块内，都必须包含一个-default-语句并且放在最后，即使它什么代码也没有。"><a href="#【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止-；-在一个-switch-块内，都必须包含一个-default-语句并且放在最后，即使它什么代码也没有。" class="headerlink" title="【强制】在一个 switch 块内，每个 case 要么通过 break / return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止 ； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。"></a>【强制】在一个 switch 块内，每个 case 要么通过 break / return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止 ； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。</h4><h4 id="【推荐】推荐尽量少用-else-，-if-else-的方式可以改写成："><a href="#【推荐】推荐尽量少用-else-，-if-else-的方式可以改写成：" class="headerlink" title="【推荐】推荐尽量少用 else ，  if - else 的方式可以改写成："></a>【推荐】推荐尽量少用 else ，  if - else 的方式可以改写成：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(condition)&#123;</div><div class="line">	...</div><div class="line">	return obj;</div><div class="line">&#125;</div><div class="line">// 接着写 else 的业务逻辑代码;</div></pre></td></tr></table></figure>
<p>说明：如果非得使用 if()…else if()…else… 方式表达逻辑，【强制】请勿超过 3 层，<br>超过请使用状态设计模式。<br>正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。<br>思考：以后实现一定注意，我以前没有注意过这一点。</p>
<h4 id="【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"><a href="#【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。" class="headerlink" title="【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"></a>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</h4><p>说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么<br>样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？</p>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//伪代码如下</div><div class="line">boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...);</div><div class="line">if (existed) &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">反例：</div><div class="line">if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的-try-catch-操作-（-这个-try-catch-是否可以移至循环体外-）-。"><a href="#【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的-try-catch-操作-（-这个-try-catch-是否可以移至循环体外-）-。" class="headerlink" title="【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try - catch 操作 （ 这个 try - catch 是否可以移至循环体外 ） 。"></a>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try - catch 操作 （ 这个 try - catch 是否可以移至循环体外 ） 。</h4><h4 id="【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"><a href="#【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。" class="headerlink" title="【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"></a>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</h4><h4 id="【参考】方法中需要进行参数校验的场景："><a href="#【参考】方法中需要进行参数校验的场景：" class="headerlink" title="【参考】方法中需要进行参数校验的场景："></a>【参考】方法中需要进行参数校验的场景：</h4><p>1 ） 调用频次低的方法。<br>2 ） 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致<br>中间执行回退，或者错误，那得不偿失。<br>3 ） 需要极高稳定性和可用性的方法。<br>4 ） 对外提供的开放接口，不管是 RPC / API / HTTP 接口。<br>5） 敏感权限入口。</p>
<h4 id="【参考】方法中不需要参数校验的场景："><a href="#【参考】方法中不需要参数校验的场景：" class="headerlink" title="【参考】方法中不需要参数校验的场景："></a>【参考】方法中不需要参数校验的场景：</h4><p>1 ） 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参<br>数检查。<br>2 ） 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错<br>误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一<br>台服务器中，所以 DAO 的参数校验，可以省略。<br>3 ） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参<br>数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p>
<h2 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h2><h4 id="【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。"><a href="#【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。" class="headerlink" title="【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用 // xxx 方式。"></a>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/<em>*内容</em>/格式，不得使用 // xxx 方式。</h4><p>说明：在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注<br>释 ； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高<br>阅读效率。</p>
<h4 id="【强制】所有的抽象方法-（-包括接口中的方法-）-必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"><a href="#【强制】所有的抽象方法-（-包括接口中的方法-）-必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。" class="headerlink" title="【强制】所有的抽象方法 （ 包括接口中的方法 ） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"></a>【强制】所有的抽象方法 （ 包括接口中的方法 ） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</h4><p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p>
<h4 id="【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"><a href="#【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。" class="headerlink" title="【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"></a>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</h4><h4 id="【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"><a href="#【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。" class="headerlink" title="【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"></a>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</h4><p>反例：“ TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p>
<h4 id="【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"><a href="#【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。" class="headerlink" title="【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"></a>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</h4><p>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，<br>就失去了导航的意义。</p>
<h4 id="【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。"><a href="#【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。" class="headerlink" title="【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。"></a>【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。</h4><p>说明：代码被注释掉有两种可能性：1 ） 后续会恢复此段代码逻辑。2 ） 永久不用。前者如果没<br>有备注信息，难以知晓注释动机。后者建议直接删掉 （ 代码仓库保存了历史代码 ） 。<br>思考：这一点我需要反思，很多时候代码舍不得删，搞得很乱，所以应该勤提交，使用git来保存历史代码；</p>
<h4 id="【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑-；-第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。"><a href="#【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑-；-第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。" class="headerlink" title="【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑 ； 第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。"></a>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑 ； 第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。</h4><p>完全没有注释的大段代码对于阅读者形同<br>天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路 ； 注释也是给继任者看<br>的，使其能够快速接替自己的工作。</p>
<h4 id="【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。"><a href="#【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。" class="headerlink" title="【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。"></a>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</h4><p>1 ） 待办事宜 （TODO） : （ 标记人，标记时间， [ 预计处理时间 ]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc<br>还没有实现，但已经被广泛使用。只能应用于类，接口和方法 （ 因为它是一个 Javadoc 标签 ） 。<br>2 ） 错误，不能工作 （FIXME） : （ 标记人，标记时间， [ 预计处理时间 ]）<br>在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h4 id="【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"><a href="#【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。" class="headerlink" title="【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"></a>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</h4><p>说明：不要在方法体内定义： Pattern pattern =  Pattern . compile( 规则 );</p>
<h4 id="【强制】后台输送给页面的变量必须加-var-——中间的感叹号。"><a href="#【强制】后台输送给页面的变量必须加-var-——中间的感叹号。" class="headerlink" title="【强制】后台输送给页面的变量必须加 $!{var} ——中间的感叹号。"></a>【强制】后台输送给页面的变量必须加 $!{var} ——中间的感叹号。</h4><p>说明：如果 var = null 或者不存在，那么 ${var} 会直接显示在页面上。<br>思考：这里是 Velocity 模板引擎的一些内容，Velocity是一个基于Java的模板引擎，通过特定的语法，Velocity可以获取在java语言中定义的对象，从而实现界面和java代码的真正分离，这意味着可以使用velocity替代jsp的开发模式了。这使得前端开发人员可以和 Java 程序开发人员同步开发一个遵循 MVC 架构的 web 站点，在实际应用中，velocity还可以应用于很多其他的场景。，比如源代码生成、自动email和转换xml等。</p>
<h4 id="【强制】注意-Math-random-这个方法返回是-double-类型，注意取值的范围-0≤-x-lt-1-（-能够取到零值，注意除零异常-）-，如果想获取整数类型的随机数，不要将-x-放大-10-的若干倍然后取整，直接使用-Random-对象的-nextInt-或者-nextLong-方法。"><a href="#【强制】注意-Math-random-这个方法返回是-double-类型，注意取值的范围-0≤-x-lt-1-（-能够取到零值，注意除零异常-）-，如果想获取整数类型的随机数，不要将-x-放大-10-的若干倍然后取整，直接使用-Random-对象的-nextInt-或者-nextLong-方法。" class="headerlink" title="【强制】注意  Math . random() 这个方法返回是 double 类型，注意取值的范围 0≤ x &lt;1 （ 能够取到零值，注意除零异常 ） ，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。"></a>【强制】注意  Math . random() 这个方法返回是 double 类型，注意取值的范围 0≤ x &lt;1 （ 能够取到零值，注意除零异常 ） ，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</h4><h4 id="【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime"><a href="#【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime" class="headerlink" title="【强制】获取当前毫秒数 System . currentTimeMillis(); 而不是 new Date() . getTime();"></a>【强制】获取当前毫秒数 System . currentTimeMillis(); 而不是 new Date() . getTime();</h4><p>说明：如果想获取更加精确的纳秒级时间值，用 System . nanoTime() 。在 JDK 8 中，针对统计时间等场景，推荐使用 Instant类。</p>
<h4 id="【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"><a href="#【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。" class="headerlink" title="【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"></a>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</h4><h4 id="【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。"><a href="#【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。" class="headerlink" title="【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。"></a>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</h4></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://flume.cn/2017/03/13/阿里巴巴Java开发手册学习笔记/" data-id="cjgd2byfl002yegguwod7u34q" class="article-share-link">分享</a><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a href="/2017/03/23/flume1-7使用KafkaSource采集大量数据/" class="pre">flume1.7使用KafkaSource采集大量数据</a><a href="/2017/03/10/Apache-Eagle定义一个Application/" class="next">Apache-Eagle定义一个Application</a></div><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2139407"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/eagle/">eagle</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark开发/">spark开发</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring-cloud/">spring cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/单车岁月/">单车岁月</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/大数据开发/" style="font-size: 15px;">大数据开发</a> <a href="/tags/scala/" style="font-size: 15px;">scala</a> <a href="/tags/hue/" style="font-size: 15px;">hue</a> <a href="/tags/kerberos/" style="font-size: 15px;">kerberos</a> <a href="/tags/livy/" style="font-size: 15px;">livy</a> <a href="/tags/hbase/" style="font-size: 15px;">hbase</a> <a href="/tags/yarn/" style="font-size: 15px;">yarn</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/flume/" style="font-size: 15px;">flume</a> <a href="/tags/spark-streaming/" style="font-size: 15px;">spark streaming</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/持续更新/" style="font-size: 15px;">持续更新</a> <a href="/tags/spark开发/" style="font-size: 15px;">spark开发</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/散文/" style="font-size: 15px;">散文</a> <a href="/tags/eagle/" style="font-size: 15px;">eagle</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/spring-cloud/" style="font-size: 15px;">spring cloud</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/es/" style="font-size: 15px;">es</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/08/spark2-2新版本编译打包/">spark2.2新版本编译打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/使用Ansable安装管理Spark客户端/">使用Ansable安装管理Spark客户端</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/spark往ES中写入数据的方法/">spark往ES中写入数据的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/spark指定java版本向yarn提交程序/">spark在yarn中运行jdk8</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/返回区域实时人数的思路与总结/">返回区域实时人数的思路与总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/位置服务开发上线总结/">位置服务开发上线总结————实时数据推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/spark奇技淫巧总结之flatMap/">spark奇技淫巧总结之强大的flatMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/OpenAPI微服务接入规范/">OpenAPI微服务接入规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/29/OpenApi之我浅薄见解/">OpenApi之我浅薄见解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/24/阿里巴巴Java开发手册学习笔记2/">阿里巴巴Java开发手册学习笔记（下）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://issues.apache.org/jira/secure/Dashboard.jspa" title="有问题上JIRA" target="_blank">有问题上JIRA</a><ul></ul><a href="https://github.com/lw-lin/CoolplaySpark" title="酷玩 Spark" target="_blank">酷玩 Spark</a><ul></ul><a href="http://lqding.blog.51cto.com" title="叮咚的51博客" target="_blank">叮咚的51博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Adam Home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>